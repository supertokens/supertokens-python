<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>supertokens_python.supertokens API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>supertokens_python.supertokens</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.
#
# This software is licensed under the Apache License, Version 2.0 (the
# &#34;License&#34;) as published by the Apache Software Foundation.
#
# You may not use this file except in compliance with the License. You may
# obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, List, Set, Union

from typing_extensions import Literal

from supertokens_python.logger import get_maybe_none_as_str, log_debug_message

from .constants import (FDI_KEY_HEADER, RID_KEY_HEADER, TELEMETRY,
                        TELEMETRY_SUPERTOKENS_API_URL,
                        TELEMETRY_SUPERTOKENS_API_VERSION, USER_COUNT,
                        USER_DELETE, USERS)
from .exceptions import SuperTokensError
from .normalised_url_domain import NormalisedURLDomain
from .normalised_url_path import NormalisedURLPath
from .querier import Querier
from .recipe.session.cookie_and_header import (
    attach_access_token_to_cookie, attach_anti_csrf_header,
    attach_id_refresh_token_to_cookie_and_header,
    attach_refresh_token_to_cookie, clear_cookies, set_front_token_in_headers)
from .types import ThirdPartyInfo, User, UsersResponse
from .utils import (compare_version, get_rid_from_request,
                    normalise_http_method, send_non_200_response)

if TYPE_CHECKING:
    from .recipe_module import RecipeModule
    from supertokens_python.framework.request import BaseRequest
    from supertokens_python.framework.response import BaseResponse
    from supertokens_python.recipe.session import SessionContainer

import json
from os import environ

from httpx import AsyncClient

from .exceptions import BadInputError, GeneralError, raise_general_exception
from .recipe.session import SessionRecipe


class SupertokensConfig:
    def __init__(self, connection_uri: str, api_key: Union[str, None] = None):  # We keep this = None here because this is directly used by the user.
        self.connection_uri = connection_uri
        self.api_key = api_key


class Host:
    def __init__(self, domain: NormalisedURLDomain,
                 base_path: NormalisedURLPath):
        self.domain = domain
        self.base_path = base_path


class InputAppInfo:
    def __init__(self,
                 app_name: str,
                 api_domain: str,
                 website_domain: str,
                 api_gateway_path: str = &#39;&#39;,
                 api_base_path: str = &#39;/auth&#39;,
                 website_base_path: str = &#39;/auth&#39;,
                 ):
        self.app_name = app_name
        self.api_gateway_path = api_gateway_path
        self.api_domain = api_domain
        self.website_domain = website_domain
        self.api_base_path = api_base_path
        self.website_base_path = website_base_path


class AppInfo:
    def __init__(self, app_name: str, api_domain: str, website_domain: str,
                 framework: Literal[&#39;fastapi&#39;, &#39;flask&#39;, &#39;django&#39;], api_gateway_path: str,
                 api_base_path: str, website_base_path: str,
                 mode: Union[Literal[&#39;asgi&#39;, &#39;wsgi&#39;], None]):
        self.app_name = app_name
        self.api_gateway_path: NormalisedURLPath = NormalisedURLPath(
            api_gateway_path)
        self.api_domain: NormalisedURLDomain = NormalisedURLDomain(api_domain)
        self.website_domain: NormalisedURLDomain = NormalisedURLDomain(
            website_domain)
        self.api_base_path: NormalisedURLPath = self.api_gateway_path.append(
            NormalisedURLPath(api_base_path))
        self.website_base_path: NormalisedURLPath = NormalisedURLPath(
            website_base_path)
        if mode is not None:
            self.mode = mode
        elif framework == &#39;fastapi&#39;:
            mode = &#39;asgi&#39;
        else:
            mode = &#39;wsgi&#39;
        self.framework = framework
        self.mode = mode

    def toJSON(self):
        def defaultImpl(o: Any):
            if isinstance(o, (NormalisedURLDomain, NormalisedURLPath)):
                return o.get_as_string_dangerous()
            return o.__dict__
        return json.dumps(self, default=defaultImpl,
                          sort_keys=True, indent=4)


def manage_cookies_post_response(session: SessionContainer, response: BaseResponse):
    recipe = SessionRecipe.get_instance()
    if session[&#39;remove_cookies&#39;]:
        clear_cookies(recipe, response)
    else:
        access_token = session[&#39;new_access_token_info&#39;]
        if access_token is not None:
            attach_access_token_to_cookie(
                recipe,
                response,
                access_token[&#39;token&#39;],
                access_token[&#39;expiry&#39;]
            )
            set_front_token_in_headers(
                response,
                session[&#39;user_id&#39;],
                access_token[&#39;expiry&#39;],
                session[&#39;access_token_payload&#39;]
            )
        refresh_token = session[&#39;new_refresh_token_info&#39;]
        if refresh_token is not None:
            attach_refresh_token_to_cookie(
                recipe,
                response,
                refresh_token[&#39;token&#39;],
                refresh_token[&#39;expiry&#39;]
            )
        id_refresh_token = session[&#39;new_id_refresh_token_info&#39;]
        if id_refresh_token is not None:
            attach_id_refresh_token_to_cookie_and_header(
                recipe,
                response,
                id_refresh_token[&#39;token&#39;],
                id_refresh_token[&#39;expiry&#39;]
            )
        anti_csrf_token = session[&#39;new_anti_csrf_token&#39;]
        if anti_csrf_token is not None:
            attach_anti_csrf_header(response, anti_csrf_token)


class Supertokens:
    __instance = None

    def __init__(self,
                 app_info: InputAppInfo,
                 framework: Literal[&#39;fastapi&#39;, &#39;flask&#39;, &#39;django&#39;],
                 supertokens_config: SupertokensConfig,
                 recipe_list: List[Callable[[AppInfo], RecipeModule]],
                 mode: Union[Literal[&#39;asgi&#39;, &#39;wsgi&#39;], None],
                 telemetry: Union[bool, None]
                 ):
        self.app_info = AppInfo(
            app_info.app_name,
            app_info.api_domain,
            app_info.website_domain,
            framework,
            app_info.api_gateway_path,
            app_info.api_base_path,
            app_info.website_base_path,
            mode
        )
        log_debug_message(&#34;Started SuperTokens with debug logging (supertokens.init called)&#34;)
        log_debug_message(&#34;app_info: %s&#34;, self.app_info.toJSON())
        log_debug_message(&#34;framework: %s&#34;, framework)
        hosts = list(map(lambda h: Host(NormalisedURLDomain(h.strip()), NormalisedURLPath(h.strip())),
                         filter(lambda x: x != &#39;&#39;, supertokens_config.connection_uri.split(&#39;;&#39;))))
        Querier.init(hosts, supertokens_config.api_key)

        if len(recipe_list) == 0:
            raise_general_exception(
                &#39;Please provide at least one recipe to the supertokens.init function call&#39;)

        self.recipe_modules: List[RecipeModule] = list(
            map(lambda func: func(self.app_info), recipe_list))

        if telemetry is None:
            telemetry = (&#39;SUPERTOKENS_ENV&#39; not in environ) or (
                environ[&#39;SUPERTOKENS_ENV&#39;] != &#39;testing&#39;)

        if telemetry:
            _ = self.send_telemetry()

    async def send_telemetry(self):
        try:
            querier = Querier.get_instance(None)
            response = await querier.send_get_request(NormalisedURLPath(TELEMETRY), {})
            telemetry_id = None
            if &#39;exists&#39; in response and response[&#39;exists&#39;] and &#39;telemetry_id&#39; in response:
                telemetry_id = response[&#39;telemetry_id&#39;]
            data = {
                &#39;appName&#39;: self.app_info.app_name,
                &#39;websiteDomain&#39;: self.app_info.website_domain.get_as_string_dangerous(),
                &#39;sdk&#39;: &#39;python&#39;
            }
            if telemetry_id is not None:
                data = {
                    **data,
                    &#39;telemetryId&#39;: telemetry_id
                }
            async with AsyncClient() as client:
                await client.post(url=TELEMETRY_SUPERTOKENS_API_URL, json=data,  # type: ignore
                                  headers={&#39;api-version&#39;: TELEMETRY_SUPERTOKENS_API_VERSION})
        except Exception:
            pass

    @staticmethod
    def init(app_info: InputAppInfo,
             framework: Literal[&#39;fastapi&#39;, &#39;flask&#39;, &#39;django&#39;],
             supertokens_config: SupertokensConfig,
             recipe_list: List[Callable[[AppInfo], RecipeModule]],
             mode: Union[Literal[&#39;asgi&#39;, &#39;wsgi&#39;], None],
             telemetry: Union[bool, None]):
        if Supertokens.__instance is None:
            Supertokens.__instance = Supertokens(
                app_info, framework, supertokens_config, recipe_list, mode, telemetry)

    @staticmethod
    def reset():
        if (&#39;SUPERTOKENS_ENV&#39; not in environ) or (
                environ[&#39;SUPERTOKENS_ENV&#39;] != &#39;testing&#39;):
            raise_general_exception(
                &#39;calling testing function in non testing env&#39;)
        Querier.reset()
        Supertokens.__instance = None

    @staticmethod
    def get_instance() -&gt; Supertokens:
        if Supertokens.__instance is not None:
            return Supertokens.__instance
        raise_general_exception(
            &#39;Initialisation not done. Did you forget to call the SuperTokens.init function?&#39;)

    def get_all_cors_headers(self) -&gt; List[str]:
        headers_set: Set[str] = set()
        headers_set.add(RID_KEY_HEADER)
        headers_set.add(FDI_KEY_HEADER)
        for recipe in self.recipe_modules:
            headers = recipe.get_all_cors_headers()
            for header in headers:
                headers_set.add(header)

        return list(headers_set)

    async def get_user_count(self, include_recipe_ids: Union[None, List[str]]) -&gt; int:  # pylint: disable=no-self-use
        querier = Querier.get_instance(None)
        include_recipe_ids_str = None
        if include_recipe_ids is not None:
            include_recipe_ids_str = &#39;,&#39;.join(include_recipe_ids)

        response = await querier.send_get_request(NormalisedURLPath(USER_COUNT), {
            &#34;includeRecipeIds&#34;: include_recipe_ids_str
        })

        return int(response[&#39;count&#39;])

    async def delete_user(self, user_id: str) -&gt; None:  # pylint: disable=no-self-use
        querier = Querier.get_instance(None)

        cdi_version = await querier.get_api_version()

        if compare_version(cdi_version, &#34;2.10&#34;) == cdi_version:
            await querier.send_post_request(NormalisedURLPath(USER_DELETE), {
                &#34;userId&#34;: user_id
            })

            return None
        raise_general_exception(
            &#39;Please upgrade the SuperTokens core to &gt;= 3.7.0&#39;)

    async def get_users(self, time_joined_order: Literal[&#39;ASC&#39;, &#39;DESC&#39;],  # pylint: disable=no-self-use
                        limit: Union[int, None], pagination_token: Union[str, None],
                        include_recipe_ids: Union[None, List[str]]) -&gt; UsersResponse:
        querier = Querier.get_instance(None)
        params = {
            &#39;timeJoinedOrder&#39;: time_joined_order
        }
        if limit is not None:
            params = {
                &#39;limit&#39;: limit,
                **params
            }
        if pagination_token is not None:
            params = {
                &#39;paginationToken&#39;: pagination_token,
                **params
            }

        include_recipe_ids_str = None
        if include_recipe_ids is not None:
            include_recipe_ids_str = &#39;,&#39;.join(include_recipe_ids)
            params = {
                &#39;includeRecipeIds&#39;: include_recipe_ids_str,
                **params
            }

        response = await querier.send_get_request(NormalisedURLPath(USERS), params)
        next_pagination_token = None
        if &#39;nextPaginationToken&#39; in response:
            next_pagination_token = response[&#39;nextPaginationToken&#39;]
        users_list = response[&#39;users&#39;]
        users: List[User] = []
        for user in users_list:
            recipe_id = user[&#39;recipeId&#39;]
            user_obj = user[&#39;user&#39;]
            third_party = None
            if &#39;thirdParty&#39; in user_obj:
                third_party = ThirdPartyInfo(
                    user_obj[&#39;thirdParty&#39;][&#39;userId&#39;],
                    user_obj[&#39;thirdParty&#39;][&#39;id&#39;]
                )
            email = None
            if &#39;email&#39; in user_obj:
                email = user_obj[&#39;email&#39;]
            phone_number = None
            if &#39;phoneNumber&#39; in user_obj:
                phone_number = user_obj[&#39;phoneNumber&#39;]
            users.append(User(
                recipe_id, user_obj[&#39;id&#39;], user_obj[&#39;timeJoined&#39;], email, phone_number, third_party))

        return UsersResponse(users, next_pagination_token)

    async def middleware(self, request: BaseRequest, response: BaseResponse) -&gt; Union[BaseResponse, None]:  # pylint: disable=no-self-use
        log_debug_message(&#34;middleware: Started&#34;)
        path = Supertokens.get_instance().app_info.api_gateway_path.append(
            NormalisedURLPath(
                request.get_path()))
        method = normalise_http_method(request.method())

        if not path.startswith(
                Supertokens.get_instance().app_info.api_base_path):
            log_debug_message(
                &#34;middleware: Not handling because request path did not start with config path. Request path: %s&#34;, path.get_as_string_dangerous()
            )
            return None
        request_rid = get_rid_from_request(request)
        log_debug_message(&#34;middleware: requestRID is: %s&#34;, get_maybe_none_as_str(request_rid))
        if request_rid is not None and request_rid == &#39;anti-csrf&#39;:
            # see
            # https://github.com/supertokens/supertokens-python/issues/54
            request_rid = None
        request_id = None
        matched_recipe = None
        if request_rid is not None:
            for recipe in Supertokens.get_instance().recipe_modules:
                log_debug_message(&#34;middleware: Checking recipe ID for match: %s&#34;, recipe.get_recipe_id())
                if recipe.get_recipe_id() == request_rid:
                    matched_recipe = recipe
                    break
            if matched_recipe is not None:
                request_id = matched_recipe.return_api_id_if_can_handle_request(
                    path, method)
        else:
            for recipe in Supertokens.get_instance().recipe_modules:
                log_debug_message(&#34;middleware: Checking recipe ID for match: %s&#34;, recipe.get_recipe_id())
                request_id = recipe.return_api_id_if_can_handle_request(
                    path, method)
                if request_id is not None:
                    matched_recipe = recipe
                    break
        if matched_recipe is not None:
            log_debug_message(&#34;middleware: Matched with recipe ID: %s&#34;, matched_recipe.get_recipe_id())
        else:
            log_debug_message(&#34;middleware: Not handling because no recipe matched&#34;)
        if matched_recipe is not None and request_id is None:
            log_debug_message(&#34;middleware: Not handling because recipe doesn&#39;t handle request path or method. Request path: %s, request method: %s&#34;, path.get_as_string_dangerous(), method)
        if request_id is not None and matched_recipe is not None:
            log_debug_message(&#34;middleware: Request being handled by recipe. ID is: %s&#34;, request_id)
            api_resp = await matched_recipe.handle_api_request(request_id, request, path, method, response)
            if api_resp is None:
                log_debug_message(&#34;middleware: Not handled because API returned None&#34;)
            else:
                log_debug_message(&#34;middleware: Ended&#34;)
            return api_resp
        return None

    async def handle_supertokens_error(self, request: BaseRequest, err: Exception, response: BaseResponse):
        log_debug_message(&#34;errorHandler: Started&#34;)
        log_debug_message(&#34;errorHandler: Error is from SuperTokens recipe. Message: %s&#34;, str(err))
        if isinstance(err, GeneralError):
            raise err

        if isinstance(err, BadInputError):
            log_debug_message(&#34;errorHandler: Sending 400 status code response&#34;)
            return send_non_200_response(str(err), 400, response)

        for recipe in self.recipe_modules:
            log_debug_message(&#34;errorHandler: Checking recipe for match: %s&#34;, recipe.get_recipe_id())
            if recipe.is_error_from_this_recipe_based_on_instance(
                    err) and isinstance(err, SuperTokensError):
                log_debug_message(&#34;errorHandler: Matched with recipeID: %s&#34;, recipe.get_recipe_id())
                return await recipe.handle_error(request, err, response)
        raise err</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="supertokens_python.supertokens.manage_cookies_post_response"><code class="name flex">
<span>def <span class="ident">manage_cookies_post_response</span></span>(<span>session: SessionContainer, response: BaseResponse)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manage_cookies_post_response(session: SessionContainer, response: BaseResponse):
    recipe = SessionRecipe.get_instance()
    if session[&#39;remove_cookies&#39;]:
        clear_cookies(recipe, response)
    else:
        access_token = session[&#39;new_access_token_info&#39;]
        if access_token is not None:
            attach_access_token_to_cookie(
                recipe,
                response,
                access_token[&#39;token&#39;],
                access_token[&#39;expiry&#39;]
            )
            set_front_token_in_headers(
                response,
                session[&#39;user_id&#39;],
                access_token[&#39;expiry&#39;],
                session[&#39;access_token_payload&#39;]
            )
        refresh_token = session[&#39;new_refresh_token_info&#39;]
        if refresh_token is not None:
            attach_refresh_token_to_cookie(
                recipe,
                response,
                refresh_token[&#39;token&#39;],
                refresh_token[&#39;expiry&#39;]
            )
        id_refresh_token = session[&#39;new_id_refresh_token_info&#39;]
        if id_refresh_token is not None:
            attach_id_refresh_token_to_cookie_and_header(
                recipe,
                response,
                id_refresh_token[&#39;token&#39;],
                id_refresh_token[&#39;expiry&#39;]
            )
        anti_csrf_token = session[&#39;new_anti_csrf_token&#39;]
        if anti_csrf_token is not None:
            attach_anti_csrf_header(response, anti_csrf_token)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="supertokens_python.supertokens.AppInfo"><code class="flex name class">
<span>class <span class="ident">AppInfo</span></span>
<span>(</span><span>app_name: str, api_domain: str, website_domain: str, framework: "Literal['fastapi', 'flask', 'django']", api_gateway_path: str, api_base_path: str, website_base_path: str, mode: "Union[Literal['asgi', 'wsgi'], None]")</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppInfo:
    def __init__(self, app_name: str, api_domain: str, website_domain: str,
                 framework: Literal[&#39;fastapi&#39;, &#39;flask&#39;, &#39;django&#39;], api_gateway_path: str,
                 api_base_path: str, website_base_path: str,
                 mode: Union[Literal[&#39;asgi&#39;, &#39;wsgi&#39;], None]):
        self.app_name = app_name
        self.api_gateway_path: NormalisedURLPath = NormalisedURLPath(
            api_gateway_path)
        self.api_domain: NormalisedURLDomain = NormalisedURLDomain(api_domain)
        self.website_domain: NormalisedURLDomain = NormalisedURLDomain(
            website_domain)
        self.api_base_path: NormalisedURLPath = self.api_gateway_path.append(
            NormalisedURLPath(api_base_path))
        self.website_base_path: NormalisedURLPath = NormalisedURLPath(
            website_base_path)
        if mode is not None:
            self.mode = mode
        elif framework == &#39;fastapi&#39;:
            mode = &#39;asgi&#39;
        else:
            mode = &#39;wsgi&#39;
        self.framework = framework
        self.mode = mode

    def toJSON(self):
        def defaultImpl(o: Any):
            if isinstance(o, (NormalisedURLDomain, NormalisedURLPath)):
                return o.get_as_string_dangerous()
            return o.__dict__
        return json.dumps(self, default=defaultImpl,
                          sort_keys=True, indent=4)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="supertokens_python.supertokens.AppInfo.toJSON"><code class="name flex">
<span>def <span class="ident">toJSON</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toJSON(self):
    def defaultImpl(o: Any):
        if isinstance(o, (NormalisedURLDomain, NormalisedURLPath)):
            return o.get_as_string_dangerous()
        return o.__dict__
    return json.dumps(self, default=defaultImpl,
                      sort_keys=True, indent=4)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="supertokens_python.supertokens.Host"><code class="flex name class">
<span>class <span class="ident">Host</span></span>
<span>(</span><span>domain: NormalisedURLDomain, base_path: NormalisedURLPath)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Host:
    def __init__(self, domain: NormalisedURLDomain,
                 base_path: NormalisedURLPath):
        self.domain = domain
        self.base_path = base_path</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.InputAppInfo"><code class="flex name class">
<span>class <span class="ident">InputAppInfo</span></span>
<span>(</span><span>app_name: str, api_domain: str, website_domain: str, api_gateway_path: str = '', api_base_path: str = '/auth', website_base_path: str = '/auth')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputAppInfo:
    def __init__(self,
                 app_name: str,
                 api_domain: str,
                 website_domain: str,
                 api_gateway_path: str = &#39;&#39;,
                 api_base_path: str = &#39;/auth&#39;,
                 website_base_path: str = &#39;/auth&#39;,
                 ):
        self.app_name = app_name
        self.api_gateway_path = api_gateway_path
        self.api_domain = api_domain
        self.website_domain = website_domain
        self.api_base_path = api_base_path
        self.website_base_path = website_base_path</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens"><code class="flex name class">
<span>class <span class="ident">Supertokens</span></span>
<span>(</span><span>app_info: <a title="supertokens_python.supertokens.InputAppInfo" href="#supertokens_python.supertokens.InputAppInfo">InputAppInfo</a>, framework: "Literal['fastapi', 'flask', 'django']", supertokens_config: <a title="supertokens_python.supertokens.SupertokensConfig" href="#supertokens_python.supertokens.SupertokensConfig">SupertokensConfig</a>, recipe_list: List[Callable[[<a title="supertokens_python.supertokens.AppInfo" href="#supertokens_python.supertokens.AppInfo">AppInfo</a>], RecipeModule]], mode: "Union[Literal['asgi', 'wsgi'], None]", telemetry: Union[bool, None])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Supertokens:
    __instance = None

    def __init__(self,
                 app_info: InputAppInfo,
                 framework: Literal[&#39;fastapi&#39;, &#39;flask&#39;, &#39;django&#39;],
                 supertokens_config: SupertokensConfig,
                 recipe_list: List[Callable[[AppInfo], RecipeModule]],
                 mode: Union[Literal[&#39;asgi&#39;, &#39;wsgi&#39;], None],
                 telemetry: Union[bool, None]
                 ):
        self.app_info = AppInfo(
            app_info.app_name,
            app_info.api_domain,
            app_info.website_domain,
            framework,
            app_info.api_gateway_path,
            app_info.api_base_path,
            app_info.website_base_path,
            mode
        )
        log_debug_message(&#34;Started SuperTokens with debug logging (supertokens.init called)&#34;)
        log_debug_message(&#34;app_info: %s&#34;, self.app_info.toJSON())
        log_debug_message(&#34;framework: %s&#34;, framework)
        hosts = list(map(lambda h: Host(NormalisedURLDomain(h.strip()), NormalisedURLPath(h.strip())),
                         filter(lambda x: x != &#39;&#39;, supertokens_config.connection_uri.split(&#39;;&#39;))))
        Querier.init(hosts, supertokens_config.api_key)

        if len(recipe_list) == 0:
            raise_general_exception(
                &#39;Please provide at least one recipe to the supertokens.init function call&#39;)

        self.recipe_modules: List[RecipeModule] = list(
            map(lambda func: func(self.app_info), recipe_list))

        if telemetry is None:
            telemetry = (&#39;SUPERTOKENS_ENV&#39; not in environ) or (
                environ[&#39;SUPERTOKENS_ENV&#39;] != &#39;testing&#39;)

        if telemetry:
            _ = self.send_telemetry()

    async def send_telemetry(self):
        try:
            querier = Querier.get_instance(None)
            response = await querier.send_get_request(NormalisedURLPath(TELEMETRY), {})
            telemetry_id = None
            if &#39;exists&#39; in response and response[&#39;exists&#39;] and &#39;telemetry_id&#39; in response:
                telemetry_id = response[&#39;telemetry_id&#39;]
            data = {
                &#39;appName&#39;: self.app_info.app_name,
                &#39;websiteDomain&#39;: self.app_info.website_domain.get_as_string_dangerous(),
                &#39;sdk&#39;: &#39;python&#39;
            }
            if telemetry_id is not None:
                data = {
                    **data,
                    &#39;telemetryId&#39;: telemetry_id
                }
            async with AsyncClient() as client:
                await client.post(url=TELEMETRY_SUPERTOKENS_API_URL, json=data,  # type: ignore
                                  headers={&#39;api-version&#39;: TELEMETRY_SUPERTOKENS_API_VERSION})
        except Exception:
            pass

    @staticmethod
    def init(app_info: InputAppInfo,
             framework: Literal[&#39;fastapi&#39;, &#39;flask&#39;, &#39;django&#39;],
             supertokens_config: SupertokensConfig,
             recipe_list: List[Callable[[AppInfo], RecipeModule]],
             mode: Union[Literal[&#39;asgi&#39;, &#39;wsgi&#39;], None],
             telemetry: Union[bool, None]):
        if Supertokens.__instance is None:
            Supertokens.__instance = Supertokens(
                app_info, framework, supertokens_config, recipe_list, mode, telemetry)

    @staticmethod
    def reset():
        if (&#39;SUPERTOKENS_ENV&#39; not in environ) or (
                environ[&#39;SUPERTOKENS_ENV&#39;] != &#39;testing&#39;):
            raise_general_exception(
                &#39;calling testing function in non testing env&#39;)
        Querier.reset()
        Supertokens.__instance = None

    @staticmethod
    def get_instance() -&gt; Supertokens:
        if Supertokens.__instance is not None:
            return Supertokens.__instance
        raise_general_exception(
            &#39;Initialisation not done. Did you forget to call the SuperTokens.init function?&#39;)

    def get_all_cors_headers(self) -&gt; List[str]:
        headers_set: Set[str] = set()
        headers_set.add(RID_KEY_HEADER)
        headers_set.add(FDI_KEY_HEADER)
        for recipe in self.recipe_modules:
            headers = recipe.get_all_cors_headers()
            for header in headers:
                headers_set.add(header)

        return list(headers_set)

    async def get_user_count(self, include_recipe_ids: Union[None, List[str]]) -&gt; int:  # pylint: disable=no-self-use
        querier = Querier.get_instance(None)
        include_recipe_ids_str = None
        if include_recipe_ids is not None:
            include_recipe_ids_str = &#39;,&#39;.join(include_recipe_ids)

        response = await querier.send_get_request(NormalisedURLPath(USER_COUNT), {
            &#34;includeRecipeIds&#34;: include_recipe_ids_str
        })

        return int(response[&#39;count&#39;])

    async def delete_user(self, user_id: str) -&gt; None:  # pylint: disable=no-self-use
        querier = Querier.get_instance(None)

        cdi_version = await querier.get_api_version()

        if compare_version(cdi_version, &#34;2.10&#34;) == cdi_version:
            await querier.send_post_request(NormalisedURLPath(USER_DELETE), {
                &#34;userId&#34;: user_id
            })

            return None
        raise_general_exception(
            &#39;Please upgrade the SuperTokens core to &gt;= 3.7.0&#39;)

    async def get_users(self, time_joined_order: Literal[&#39;ASC&#39;, &#39;DESC&#39;],  # pylint: disable=no-self-use
                        limit: Union[int, None], pagination_token: Union[str, None],
                        include_recipe_ids: Union[None, List[str]]) -&gt; UsersResponse:
        querier = Querier.get_instance(None)
        params = {
            &#39;timeJoinedOrder&#39;: time_joined_order
        }
        if limit is not None:
            params = {
                &#39;limit&#39;: limit,
                **params
            }
        if pagination_token is not None:
            params = {
                &#39;paginationToken&#39;: pagination_token,
                **params
            }

        include_recipe_ids_str = None
        if include_recipe_ids is not None:
            include_recipe_ids_str = &#39;,&#39;.join(include_recipe_ids)
            params = {
                &#39;includeRecipeIds&#39;: include_recipe_ids_str,
                **params
            }

        response = await querier.send_get_request(NormalisedURLPath(USERS), params)
        next_pagination_token = None
        if &#39;nextPaginationToken&#39; in response:
            next_pagination_token = response[&#39;nextPaginationToken&#39;]
        users_list = response[&#39;users&#39;]
        users: List[User] = []
        for user in users_list:
            recipe_id = user[&#39;recipeId&#39;]
            user_obj = user[&#39;user&#39;]
            third_party = None
            if &#39;thirdParty&#39; in user_obj:
                third_party = ThirdPartyInfo(
                    user_obj[&#39;thirdParty&#39;][&#39;userId&#39;],
                    user_obj[&#39;thirdParty&#39;][&#39;id&#39;]
                )
            email = None
            if &#39;email&#39; in user_obj:
                email = user_obj[&#39;email&#39;]
            phone_number = None
            if &#39;phoneNumber&#39; in user_obj:
                phone_number = user_obj[&#39;phoneNumber&#39;]
            users.append(User(
                recipe_id, user_obj[&#39;id&#39;], user_obj[&#39;timeJoined&#39;], email, phone_number, third_party))

        return UsersResponse(users, next_pagination_token)

    async def middleware(self, request: BaseRequest, response: BaseResponse) -&gt; Union[BaseResponse, None]:  # pylint: disable=no-self-use
        log_debug_message(&#34;middleware: Started&#34;)
        path = Supertokens.get_instance().app_info.api_gateway_path.append(
            NormalisedURLPath(
                request.get_path()))
        method = normalise_http_method(request.method())

        if not path.startswith(
                Supertokens.get_instance().app_info.api_base_path):
            log_debug_message(
                &#34;middleware: Not handling because request path did not start with config path. Request path: %s&#34;, path.get_as_string_dangerous()
            )
            return None
        request_rid = get_rid_from_request(request)
        log_debug_message(&#34;middleware: requestRID is: %s&#34;, get_maybe_none_as_str(request_rid))
        if request_rid is not None and request_rid == &#39;anti-csrf&#39;:
            # see
            # https://github.com/supertokens/supertokens-python/issues/54
            request_rid = None
        request_id = None
        matched_recipe = None
        if request_rid is not None:
            for recipe in Supertokens.get_instance().recipe_modules:
                log_debug_message(&#34;middleware: Checking recipe ID for match: %s&#34;, recipe.get_recipe_id())
                if recipe.get_recipe_id() == request_rid:
                    matched_recipe = recipe
                    break
            if matched_recipe is not None:
                request_id = matched_recipe.return_api_id_if_can_handle_request(
                    path, method)
        else:
            for recipe in Supertokens.get_instance().recipe_modules:
                log_debug_message(&#34;middleware: Checking recipe ID for match: %s&#34;, recipe.get_recipe_id())
                request_id = recipe.return_api_id_if_can_handle_request(
                    path, method)
                if request_id is not None:
                    matched_recipe = recipe
                    break
        if matched_recipe is not None:
            log_debug_message(&#34;middleware: Matched with recipe ID: %s&#34;, matched_recipe.get_recipe_id())
        else:
            log_debug_message(&#34;middleware: Not handling because no recipe matched&#34;)
        if matched_recipe is not None and request_id is None:
            log_debug_message(&#34;middleware: Not handling because recipe doesn&#39;t handle request path or method. Request path: %s, request method: %s&#34;, path.get_as_string_dangerous(), method)
        if request_id is not None and matched_recipe is not None:
            log_debug_message(&#34;middleware: Request being handled by recipe. ID is: %s&#34;, request_id)
            api_resp = await matched_recipe.handle_api_request(request_id, request, path, method, response)
            if api_resp is None:
                log_debug_message(&#34;middleware: Not handled because API returned None&#34;)
            else:
                log_debug_message(&#34;middleware: Ended&#34;)
            return api_resp
        return None

    async def handle_supertokens_error(self, request: BaseRequest, err: Exception, response: BaseResponse):
        log_debug_message(&#34;errorHandler: Started&#34;)
        log_debug_message(&#34;errorHandler: Error is from SuperTokens recipe. Message: %s&#34;, str(err))
        if isinstance(err, GeneralError):
            raise err

        if isinstance(err, BadInputError):
            log_debug_message(&#34;errorHandler: Sending 400 status code response&#34;)
            return send_non_200_response(str(err), 400, response)

        for recipe in self.recipe_modules:
            log_debug_message(&#34;errorHandler: Checking recipe for match: %s&#34;, recipe.get_recipe_id())
            if recipe.is_error_from_this_recipe_based_on_instance(
                    err) and isinstance(err, SuperTokensError):
                log_debug_message(&#34;errorHandler: Matched with recipeID: %s&#34;, recipe.get_recipe_id())
                return await recipe.handle_error(request, err, response)
        raise err</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="supertokens_python.supertokens.Supertokens.get_instance"><code class="name flex">
<span>def <span class="ident">get_instance</span></span>(<span>) ‑> <a title="supertokens_python.supertokens.Supertokens" href="#supertokens_python.supertokens.Supertokens">Supertokens</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_instance() -&gt; Supertokens:
    if Supertokens.__instance is not None:
        return Supertokens.__instance
    raise_general_exception(
        &#39;Initialisation not done. Did you forget to call the SuperTokens.init function?&#39;)</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>app_info: <a title="supertokens_python.supertokens.InputAppInfo" href="#supertokens_python.supertokens.InputAppInfo">InputAppInfo</a>, framework: "Literal['fastapi', 'flask', 'django']", supertokens_config: <a title="supertokens_python.supertokens.SupertokensConfig" href="#supertokens_python.supertokens.SupertokensConfig">SupertokensConfig</a>, recipe_list: List[Callable[[<a title="supertokens_python.supertokens.AppInfo" href="#supertokens_python.supertokens.AppInfo">AppInfo</a>], RecipeModule]], mode: "Union[Literal['asgi', 'wsgi'], None]", telemetry: Union[bool, None])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init(app_info: InputAppInfo,
         framework: Literal[&#39;fastapi&#39;, &#39;flask&#39;, &#39;django&#39;],
         supertokens_config: SupertokensConfig,
         recipe_list: List[Callable[[AppInfo], RecipeModule]],
         mode: Union[Literal[&#39;asgi&#39;, &#39;wsgi&#39;], None],
         telemetry: Union[bool, None]):
    if Supertokens.__instance is None:
        Supertokens.__instance = Supertokens(
            app_info, framework, supertokens_config, recipe_list, mode, telemetry)</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def reset():
    if (&#39;SUPERTOKENS_ENV&#39; not in environ) or (
            environ[&#39;SUPERTOKENS_ENV&#39;] != &#39;testing&#39;):
        raise_general_exception(
            &#39;calling testing function in non testing env&#39;)
    Querier.reset()
    Supertokens.__instance = None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="supertokens_python.supertokens.Supertokens.delete_user"><code class="name flex">
<span>async def <span class="ident">delete_user</span></span>(<span>self, user_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_user(self, user_id: str) -&gt; None:  # pylint: disable=no-self-use
    querier = Querier.get_instance(None)

    cdi_version = await querier.get_api_version()

    if compare_version(cdi_version, &#34;2.10&#34;) == cdi_version:
        await querier.send_post_request(NormalisedURLPath(USER_DELETE), {
            &#34;userId&#34;: user_id
        })

        return None
    raise_general_exception(
        &#39;Please upgrade the SuperTokens core to &gt;= 3.7.0&#39;)</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.get_all_cors_headers"><code class="name flex">
<span>def <span class="ident">get_all_cors_headers</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_cors_headers(self) -&gt; List[str]:
    headers_set: Set[str] = set()
    headers_set.add(RID_KEY_HEADER)
    headers_set.add(FDI_KEY_HEADER)
    for recipe in self.recipe_modules:
        headers = recipe.get_all_cors_headers()
        for header in headers:
            headers_set.add(header)

    return list(headers_set)</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.get_user_count"><code class="name flex">
<span>async def <span class="ident">get_user_count</span></span>(<span>self, include_recipe_ids: Union[None, List[str]]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_user_count(self, include_recipe_ids: Union[None, List[str]]) -&gt; int:  # pylint: disable=no-self-use
    querier = Querier.get_instance(None)
    include_recipe_ids_str = None
    if include_recipe_ids is not None:
        include_recipe_ids_str = &#39;,&#39;.join(include_recipe_ids)

    response = await querier.send_get_request(NormalisedURLPath(USER_COUNT), {
        &#34;includeRecipeIds&#34;: include_recipe_ids_str
    })

    return int(response[&#39;count&#39;])</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.get_users"><code class="name flex">
<span>async def <span class="ident">get_users</span></span>(<span>self, time_joined_order: "Literal['ASC', 'DESC']", limit: Union[int, None], pagination_token: Union[str, None], include_recipe_ids: Union[None, List[str]]) ‑> <a title="supertokens_python.types.UsersResponse" href="types.html#supertokens_python.types.UsersResponse">UsersResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_users(self, time_joined_order: Literal[&#39;ASC&#39;, &#39;DESC&#39;],  # pylint: disable=no-self-use
                    limit: Union[int, None], pagination_token: Union[str, None],
                    include_recipe_ids: Union[None, List[str]]) -&gt; UsersResponse:
    querier = Querier.get_instance(None)
    params = {
        &#39;timeJoinedOrder&#39;: time_joined_order
    }
    if limit is not None:
        params = {
            &#39;limit&#39;: limit,
            **params
        }
    if pagination_token is not None:
        params = {
            &#39;paginationToken&#39;: pagination_token,
            **params
        }

    include_recipe_ids_str = None
    if include_recipe_ids is not None:
        include_recipe_ids_str = &#39;,&#39;.join(include_recipe_ids)
        params = {
            &#39;includeRecipeIds&#39;: include_recipe_ids_str,
            **params
        }

    response = await querier.send_get_request(NormalisedURLPath(USERS), params)
    next_pagination_token = None
    if &#39;nextPaginationToken&#39; in response:
        next_pagination_token = response[&#39;nextPaginationToken&#39;]
    users_list = response[&#39;users&#39;]
    users: List[User] = []
    for user in users_list:
        recipe_id = user[&#39;recipeId&#39;]
        user_obj = user[&#39;user&#39;]
        third_party = None
        if &#39;thirdParty&#39; in user_obj:
            third_party = ThirdPartyInfo(
                user_obj[&#39;thirdParty&#39;][&#39;userId&#39;],
                user_obj[&#39;thirdParty&#39;][&#39;id&#39;]
            )
        email = None
        if &#39;email&#39; in user_obj:
            email = user_obj[&#39;email&#39;]
        phone_number = None
        if &#39;phoneNumber&#39; in user_obj:
            phone_number = user_obj[&#39;phoneNumber&#39;]
        users.append(User(
            recipe_id, user_obj[&#39;id&#39;], user_obj[&#39;timeJoined&#39;], email, phone_number, third_party))

    return UsersResponse(users, next_pagination_token)</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.handle_supertokens_error"><code class="name flex">
<span>async def <span class="ident">handle_supertokens_error</span></span>(<span>self, request: BaseRequest, err: Exception, response: BaseResponse)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_supertokens_error(self, request: BaseRequest, err: Exception, response: BaseResponse):
    log_debug_message(&#34;errorHandler: Started&#34;)
    log_debug_message(&#34;errorHandler: Error is from SuperTokens recipe. Message: %s&#34;, str(err))
    if isinstance(err, GeneralError):
        raise err

    if isinstance(err, BadInputError):
        log_debug_message(&#34;errorHandler: Sending 400 status code response&#34;)
        return send_non_200_response(str(err), 400, response)

    for recipe in self.recipe_modules:
        log_debug_message(&#34;errorHandler: Checking recipe for match: %s&#34;, recipe.get_recipe_id())
        if recipe.is_error_from_this_recipe_based_on_instance(
                err) and isinstance(err, SuperTokensError):
            log_debug_message(&#34;errorHandler: Matched with recipeID: %s&#34;, recipe.get_recipe_id())
            return await recipe.handle_error(request, err, response)
    raise err</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.middleware"><code class="name flex">
<span>async def <span class="ident">middleware</span></span>(<span>self, request: BaseRequest, response: BaseResponse) ‑> Union[BaseResponse, None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def middleware(self, request: BaseRequest, response: BaseResponse) -&gt; Union[BaseResponse, None]:  # pylint: disable=no-self-use
    log_debug_message(&#34;middleware: Started&#34;)
    path = Supertokens.get_instance().app_info.api_gateway_path.append(
        NormalisedURLPath(
            request.get_path()))
    method = normalise_http_method(request.method())

    if not path.startswith(
            Supertokens.get_instance().app_info.api_base_path):
        log_debug_message(
            &#34;middleware: Not handling because request path did not start with config path. Request path: %s&#34;, path.get_as_string_dangerous()
        )
        return None
    request_rid = get_rid_from_request(request)
    log_debug_message(&#34;middleware: requestRID is: %s&#34;, get_maybe_none_as_str(request_rid))
    if request_rid is not None and request_rid == &#39;anti-csrf&#39;:
        # see
        # https://github.com/supertokens/supertokens-python/issues/54
        request_rid = None
    request_id = None
    matched_recipe = None
    if request_rid is not None:
        for recipe in Supertokens.get_instance().recipe_modules:
            log_debug_message(&#34;middleware: Checking recipe ID for match: %s&#34;, recipe.get_recipe_id())
            if recipe.get_recipe_id() == request_rid:
                matched_recipe = recipe
                break
        if matched_recipe is not None:
            request_id = matched_recipe.return_api_id_if_can_handle_request(
                path, method)
    else:
        for recipe in Supertokens.get_instance().recipe_modules:
            log_debug_message(&#34;middleware: Checking recipe ID for match: %s&#34;, recipe.get_recipe_id())
            request_id = recipe.return_api_id_if_can_handle_request(
                path, method)
            if request_id is not None:
                matched_recipe = recipe
                break
    if matched_recipe is not None:
        log_debug_message(&#34;middleware: Matched with recipe ID: %s&#34;, matched_recipe.get_recipe_id())
    else:
        log_debug_message(&#34;middleware: Not handling because no recipe matched&#34;)
    if matched_recipe is not None and request_id is None:
        log_debug_message(&#34;middleware: Not handling because recipe doesn&#39;t handle request path or method. Request path: %s, request method: %s&#34;, path.get_as_string_dangerous(), method)
    if request_id is not None and matched_recipe is not None:
        log_debug_message(&#34;middleware: Request being handled by recipe. ID is: %s&#34;, request_id)
        api_resp = await matched_recipe.handle_api_request(request_id, request, path, method, response)
        if api_resp is None:
            log_debug_message(&#34;middleware: Not handled because API returned None&#34;)
        else:
            log_debug_message(&#34;middleware: Ended&#34;)
        return api_resp
    return None</code></pre>
</details>
</dd>
<dt id="supertokens_python.supertokens.Supertokens.send_telemetry"><code class="name flex">
<span>async def <span class="ident">send_telemetry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_telemetry(self):
    try:
        querier = Querier.get_instance(None)
        response = await querier.send_get_request(NormalisedURLPath(TELEMETRY), {})
        telemetry_id = None
        if &#39;exists&#39; in response and response[&#39;exists&#39;] and &#39;telemetry_id&#39; in response:
            telemetry_id = response[&#39;telemetry_id&#39;]
        data = {
            &#39;appName&#39;: self.app_info.app_name,
            &#39;websiteDomain&#39;: self.app_info.website_domain.get_as_string_dangerous(),
            &#39;sdk&#39;: &#39;python&#39;
        }
        if telemetry_id is not None:
            data = {
                **data,
                &#39;telemetryId&#39;: telemetry_id
            }
        async with AsyncClient() as client:
            await client.post(url=TELEMETRY_SUPERTOKENS_API_URL, json=data,  # type: ignore
                              headers={&#39;api-version&#39;: TELEMETRY_SUPERTOKENS_API_VERSION})
    except Exception:
        pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="supertokens_python.supertokens.SupertokensConfig"><code class="flex name class">
<span>class <span class="ident">SupertokensConfig</span></span>
<span>(</span><span>connection_uri: str, api_key: Union[str, None] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SupertokensConfig:
    def __init__(self, connection_uri: str, api_key: Union[str, None] = None):  # We keep this = None here because this is directly used by the user.
        self.connection_uri = connection_uri
        self.api_key = api_key</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="supertokens_python" href="index.html">supertokens_python</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="supertokens_python.supertokens.manage_cookies_post_response" href="#supertokens_python.supertokens.manage_cookies_post_response">manage_cookies_post_response</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="supertokens_python.supertokens.AppInfo" href="#supertokens_python.supertokens.AppInfo">AppInfo</a></code></h4>
<ul class="">
<li><code><a title="supertokens_python.supertokens.AppInfo.toJSON" href="#supertokens_python.supertokens.AppInfo.toJSON">toJSON</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="supertokens_python.supertokens.Host" href="#supertokens_python.supertokens.Host">Host</a></code></h4>
</li>
<li>
<h4><code><a title="supertokens_python.supertokens.InputAppInfo" href="#supertokens_python.supertokens.InputAppInfo">InputAppInfo</a></code></h4>
</li>
<li>
<h4><code><a title="supertokens_python.supertokens.Supertokens" href="#supertokens_python.supertokens.Supertokens">Supertokens</a></code></h4>
<ul class="">
<li><code><a title="supertokens_python.supertokens.Supertokens.delete_user" href="#supertokens_python.supertokens.Supertokens.delete_user">delete_user</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.get_all_cors_headers" href="#supertokens_python.supertokens.Supertokens.get_all_cors_headers">get_all_cors_headers</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.get_instance" href="#supertokens_python.supertokens.Supertokens.get_instance">get_instance</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.get_user_count" href="#supertokens_python.supertokens.Supertokens.get_user_count">get_user_count</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.get_users" href="#supertokens_python.supertokens.Supertokens.get_users">get_users</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.handle_supertokens_error" href="#supertokens_python.supertokens.Supertokens.handle_supertokens_error">handle_supertokens_error</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.init" href="#supertokens_python.supertokens.Supertokens.init">init</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.middleware" href="#supertokens_python.supertokens.Supertokens.middleware">middleware</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.reset" href="#supertokens_python.supertokens.Supertokens.reset">reset</a></code></li>
<li><code><a title="supertokens_python.supertokens.Supertokens.send_telemetry" href="#supertokens_python.supertokens.Supertokens.send_telemetry">send_telemetry</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="supertokens_python.supertokens.SupertokensConfig" href="#supertokens_python.supertokens.SupertokensConfig">SupertokensConfig</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
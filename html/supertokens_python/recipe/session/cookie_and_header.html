<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.0" />
<title>supertokens_python.recipe.session.cookie_and_header API documentation</title>
<meta name="description" content="Documentation for supertokens_python - SuperTokens Python SDK" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>supertokens_python.recipe.session.cookie_and_header</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.
#
# This software is licensed under the Apache License, Version 2.0 (the
# &#34;License&#34;) as published by the Apache Software Foundation.
#
# You may not use this file except in compliance with the License. You may
# obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
from __future__ import annotations

from typing import TYPE_CHECKING, List, Optional
from urllib.parse import quote, unquote

from typing_extensions import Literal

from supertokens_python.constants import ONE_YEAR_IN_MS
from supertokens_python.recipe.session.exceptions import (
    raise_clear_duplicate_session_cookies_exception,
)
from supertokens_python.recipe.session.interfaces import ResponseMutator

from ...logger import log_debug_message
from .constants import (
    ACCESS_CONTROL_EXPOSE_HEADERS,
    ACCESS_TOKEN_COOKIE_KEY,
    ACCESS_TOKEN_HEADER_KEY,
    ANTI_CSRF_HEADER_KEY,
    AUTH_MODE_HEADER_KEY,
    AUTHORIZATION_HEADER_KEY,
    FRONT_TOKEN_HEADER_SET_KEY,
    REFRESH_TOKEN_COOKIE_KEY,
    REFRESH_TOKEN_HEADER_KEY,
    RID_HEADER_KEY,
    available_token_transfer_methods,
)

if TYPE_CHECKING:
    from supertokens_python.framework.request import BaseRequest
    from supertokens_python.framework.response import BaseResponse

    from .recipe import SessionRecipe
    from .utils import (
        SessionConfig,
        TokenTransferMethod,
        TokenType,
    )

from json import dumps
from typing import Any, Dict

from supertokens_python.utils import get_header, get_timestamp_ms, utf_base64encode


def build_front_token(
    user_id: str, at_expiry: int, access_token_payload: Optional[Dict[str, Any]] = None
):
    if access_token_payload is None:
        access_token_payload = {}
    token_info = {&#34;uid&#34;: user_id, &#34;ate&#34;: at_expiry, &#34;up&#34;: access_token_payload}
    return utf_base64encode(
        dumps(token_info, separators=(&#34;,&#34;, &#34;:&#34;), sort_keys=True), urlsafe=False
    )


def _set_front_token_in_headers(
    response: BaseResponse,
    front_token: str,
):
    set_header(response, FRONT_TOKEN_HEADER_SET_KEY, front_token, False)
    set_header(
        response, ACCESS_CONTROL_EXPOSE_HEADERS, FRONT_TOKEN_HEADER_SET_KEY, True
    )


def get_cors_allowed_headers():
    return [
        ANTI_CSRF_HEADER_KEY,
        RID_HEADER_KEY,
        AUTHORIZATION_HEADER_KEY,
        AUTH_MODE_HEADER_KEY,
    ]


def set_header(response: BaseResponse, key: str, value: str, allow_duplicate: bool):
    if allow_duplicate:
        old_value = response.get_header(key)
        if old_value is None:
            response.set_header(key, value)
        else:
            response.set_header(key, old_value + &#34;,&#34; + value)
    else:
        response.set_header(key, value)


def remove_header(response: BaseResponse, key: str):
    if response.get_header(key) is not None:
        response.remove_header(key)


def get_cookie(request: BaseRequest, key: str):
    cookie_val = request.get_cookie(key)
    if cookie_val is None:
        return None
    return unquote(cookie_val)


def _set_cookie(
    response: BaseResponse,
    config: SessionConfig,
    key: str,
    value: str,
    expires: int,
    path_type: Literal[&#34;refresh_token_path&#34;, &#34;access_token_path&#34;],
    request: BaseRequest,
    domain: Optional[str],
    user_context: Dict[str, Any],
):
    secure = config.cookie_secure
    same_site = config.get_cookie_same_site(request, user_context)
    path = &#34;&#34;
    if path_type == &#34;refresh_token_path&#34;:
        path = config.refresh_token_path.get_as_string_dangerous()
    elif path_type == &#34;access_token_path&#34;:
        path = &#34;/&#34;
    http_only = True
    response.set_cookie(
        key=key,
        value=quote(value, encoding=&#34;utf-8&#34;),
        expires=expires,
        path=path,
        domain=domain,
        secure=secure,
        httponly=http_only,
        samesite=same_site,
    )


def set_cookie_response_mutator(
    config: SessionConfig,
    key: str,
    value: str,
    expires: int,
    path_type: Literal[&#34;refresh_token_path&#34;, &#34;access_token_path&#34;],
    request: BaseRequest,
    domain: Optional[str] = None,
):
    domain = domain if domain is not None else config.cookie_domain

    def mutator(response: BaseResponse, user_context: Dict[str, Any]):
        return _set_cookie(
            response,
            config,
            key,
            value,
            expires,
            path_type,
            request,
            domain,
            user_context,
        )

    return mutator


def _attach_anti_csrf_header(response: BaseResponse, value: str):
    set_header(response, ANTI_CSRF_HEADER_KEY, value, False)
    set_header(response, ACCESS_CONTROL_EXPOSE_HEADERS, ANTI_CSRF_HEADER_KEY, True)


def anti_csrf_response_mutator(value: str):
    def mutator(
        response: BaseResponse,
        _: Dict[str, Any],
    ):
        return _attach_anti_csrf_header(response, value)

    return mutator


def get_anti_csrf_header(request: BaseRequest):
    return get_header(request, ANTI_CSRF_HEADER_KEY)


def get_rid_header(request: BaseRequest):
    return get_header(request, RID_HEADER_KEY)


def clear_session_from_all_token_transfer_methods(
    response: BaseResponse,
    recipe: SessionRecipe,
    request: BaseRequest,
    user_context: Dict[str, Any],
):
    # We are clearing the session in all transfermethods to be sure to override cookies in case they have been already added to the response.
    # This is done to handle the following use-case:
    # If the app overrides signInPOST to check the ban status of the user after the original implementation and throwing an UNAUTHORISED error
    # In this case: the SDK has attached cookies to the response, but none was sent with the request
    # We can&#39;t know which to clear since we can&#39;t reliably query or remove the set-cookie header added to the response (causes issues in some frameworks, i.e.: hapi)
    # The safe solution in this case is to overwrite all the response cookies/headers with an empty value, which is what we are doing here.
    for transfer_method in available_token_transfer_methods:
        _clear_session(response, recipe.config, transfer_method, request, user_context)


def clear_session_mutator(
    config: SessionConfig,
    transfer_method: TokenTransferMethod,
    request: BaseRequest,
):
    def mutator(
        response: BaseResponse,
        user_context: Dict[str, Any],
    ):
        return _clear_session(response, config, transfer_method, request, user_context)

    return mutator


def _clear_session(
    response: BaseResponse,
    config: SessionConfig,
    transfer_method: TokenTransferMethod,
    request: BaseRequest,
    user_context: Dict[str, Any],
):
    # If we can be specific about which transferMethod we want to clear, there is no reason to clear the other ones
    token_types: List[TokenType] = [&#34;access&#34;, &#34;refresh&#34;]
    for token_type in token_types:
        _set_token(
            response, config, token_type, &#34;&#34;, 0, transfer_method, request, user_context
        )

    remove_header(
        response, ANTI_CSRF_HEADER_KEY
    )  # This can be added multiple times in some cases, but that should be OK
    set_header(response, FRONT_TOKEN_HEADER_SET_KEY, &#34;remove&#34;, False)
    set_header(
        response, ACCESS_CONTROL_EXPOSE_HEADERS, FRONT_TOKEN_HEADER_SET_KEY, True
    )


def clear_session_response_mutator(
    config: SessionConfig,
    transfer_method: TokenTransferMethod,
    request: BaseRequest,
):
    def mutator(
        response: BaseResponse,
        user_context: Dict[str, Any],
    ):
        return _clear_session(response, config, transfer_method, request, user_context)

    return mutator


def get_cookie_name_from_token_type(token_type: TokenType):
    if token_type == &#34;access&#34;:
        return ACCESS_TOKEN_COOKIE_KEY
    if token_type == &#34;refresh&#34;:
        return REFRESH_TOKEN_COOKIE_KEY
    raise Exception(&#34;Unknown token type, should never happen&#34;)


def get_response_header_name_for_token_type(token_type: TokenType):
    if token_type == &#34;access&#34;:
        return ACCESS_TOKEN_HEADER_KEY
    if token_type == &#34;refresh&#34;:
        return REFRESH_TOKEN_HEADER_KEY
    raise Exception(&#34;Unknown token type, should never happen&#34;)


def get_token(
    request: BaseRequest,
    token_type: TokenType,
    transfer_method: TokenTransferMethod,
) -&gt; Optional[str]:
    if transfer_method == &#34;cookie&#34;:
        # Note: Don&#39;t use request.get_cookie() as it won&#39;t apply unquote() func
        return get_cookie(request, get_cookie_name_from_token_type(token_type))
    if transfer_method == &#34;header&#34;:
        value = request.get_header(AUTHORIZATION_HEADER_KEY)
        if value is None or not value.startswith(&#34;Bearer &#34;):
            return None

        return value[len(&#34;Bearer &#34;) :].strip()

    raise Exception(&#34;Should never happen: Unknown transferMethod: &#34; + transfer_method)


def _set_token(
    response: BaseResponse,
    config: SessionConfig,
    token_type: TokenType,
    value: str,
    expires: int,
    transfer_method: TokenTransferMethod,
    request: BaseRequest,
    user_context: Dict[str, Any],
):
    log_debug_message(&#34;Setting %s token as %s&#34;, token_type, transfer_method)
    if transfer_method == &#34;cookie&#34;:
        _set_cookie(
            response,
            config,
            get_cookie_name_from_token_type(token_type),
            value,
            expires,
            &#34;refresh_token_path&#34; if token_type == &#34;refresh&#34; else &#34;access_token_path&#34;,
            request,
            config.cookie_domain,
            user_context,
        )
    elif transfer_method == &#34;header&#34;:
        set_token_in_header(
            response,
            get_response_header_name_for_token_type(token_type),
            value,
        )


def token_response_mutator(
    config: SessionConfig,
    token_type: TokenType,
    value: str,
    expires: int,
    transfer_method: TokenTransferMethod,
    request: BaseRequest,
):
    def mutator(
        response: BaseResponse,
        user_context: Dict[str, Any],
    ):
        _set_token(
            response,
            config,
            token_type,
            value,
            expires,
            transfer_method,
            request,
            user_context,
        )

    return mutator


def set_token_in_header(response: BaseResponse, name: str, value: str):
    set_header(response, name, value, allow_duplicate=False)
    set_header(response, ACCESS_CONTROL_EXPOSE_HEADERS, name, allow_duplicate=True)


def access_token_mutator(
    access_token: str,
    front_token: str,
    config: SessionConfig,
    transfer_method: TokenTransferMethod,
    request: BaseRequest,
):
    def mutator(
        response: BaseResponse,
        user_context: Dict[str, Any],
    ):
        _set_access_token_in_response(
            response,
            access_token,
            front_token,
            config,
            transfer_method,
            request,
            user_context,
        )

    return mutator


def _set_access_token_in_response(
    res: BaseResponse,
    access_token: str,
    front_token: str,
    config: SessionConfig,
    transfer_method: TokenTransferMethod,
    request: BaseRequest,
    user_context: Dict[str, Any],
):
    _set_front_token_in_headers(res, front_token)
    _set_token(
        res,
        config,
        &#34;access&#34;,
        access_token,
        # We set the expiration to 1 year, because we can&#39;t really access the expiration of the refresh token everywhere we are setting it.
        # This should be safe to do, since this is only the validity of the cookie (set here or on the frontend) but we check the expiration of the JWT anyway.
        # Even if the token is expired the presence of the token indicates that the user could have a valid refresh
        # Some browsers now cap the maximum expiry at 400 days, so we set it to 1 year, which should suffice.
        get_timestamp_ms() + ONE_YEAR_IN_MS,
        transfer_method,
        request,
        user_context,
    )

    if (
        config.expose_access_token_to_frontend_in_cookie_based_auth
        and transfer_method == &#34;cookie&#34;
    ):
        _set_token(
            res,
            config,
            &#34;access&#34;,
            access_token,
            get_timestamp_ms() + ONE_YEAR_IN_MS,
            &#34;header&#34;,
            request,
            user_context,
        )


# This function addresses an edge case where changing the cookie_domain config on the server can
# lead to session integrity issues. For instance, if the API server URL is &#39;api.example.com&#39;
# with a cookie domain of &#39;.example.com&#39;, and the server updates the cookie domain to &#39;api.example.com&#39;,
# the client may retain cookies with both &#39;.example.com&#39; and &#39;api.example.com&#39; domains.

# Consequently, if the server chooses the older cookie, session invalidation occurs, potentially
# resulting in an infinite refresh loop. To fix this, users are asked to specify &#34;older_cookie_domain&#34; in
# the config.


# This function checks for multiple cookies with the same name and clears the cookies for the older domain.
def clear_session_cookies_from_older_cookie_domain(
    request: BaseRequest, config: SessionConfig, user_context: Dict[str, Any]
):
    allowed_transfer_method = config.get_token_transfer_method(
        request, False, user_context
    )
    # If the transfer method is &#39;header&#39;, there&#39;s no need to clear cookies immediately, even if there are multiple in the request.
    if allowed_transfer_method == &#34;header&#34;:
        return

    did_clear_cookies = False
    response_mutators: List[ResponseMutator] = []

    token_types: List[TokenType] = [&#34;access&#34;, &#34;refresh&#34;]
    for token_type in token_types:
        if has_multiple_cookies_for_token_type(request, token_type):
            # If a request has multiple session cookies and &#39;older_cookie_domain&#39; is
            # unset, we can&#39;t identify the correct cookie for refreshing the session.
            # Using the wrong cookie can cause an infinite refresh loop. To avoid this,
            # we throw a 500 error asking the user to set &#39;older_cookie_domain&#39;&#39;.
            if config.older_cookie_domain is None:
                raise Exception(
                    &#34;The request contains multiple session cookies. This may happen if you&#39;ve changed the &#39;cookie_domain&#39; setting in your configuration. To clear tokens from the previous domain, set &#39;older_cookie_domain&#39; in your config.&#34;
                )

            log_debug_message(
                &#34;Clearing duplicate %s cookie with domain %s&#34;,
                token_type,
                config.cookie_domain,
            )
            response_mutators.append(
                set_cookie_response_mutator(
                    config,
                    get_cookie_name_from_token_type(token_type),
                    &#34;&#34;,
                    0,
                    (
                        &#34;refresh_token_path&#34;
                        if token_type == &#34;refresh&#34;
                        else &#34;access_token_path&#34;
                    ),
                    request,
                    domain=config.older_cookie_domain,
                )
            )
            did_clear_cookies = True
    if did_clear_cookies:
        raise_clear_duplicate_session_cookies_exception(
            &#34;The request contains multiple session cookies. We are clearing the cookie from older_cookie_domain. Session will be refreshed in the next refresh call.&#34;,
            response_mutators=response_mutators,
        )


def has_multiple_cookies_for_token_type(
    request: BaseRequest, token_type: TokenType
) -&gt; bool:
    cookie_string = request.get_header(&#34;cookie&#34;)
    if cookie_string is None:
        return False

    cookies = _parse_cookie_string_from_request_header_allow_duplicates(cookie_string)
    cookie_name = get_cookie_name_from_token_type(token_type)
    return cookie_name in cookies and len(cookies[cookie_name]) &gt; 1


def _parse_cookie_string_from_request_header_allow_duplicates(
    cookie_string: str,
) -&gt; Dict[str, List[str]]:
    cookies: Dict[str, List[str]] = {}
    cookie_pairs = cookie_string.split(&#34;;&#34;)
    for cookie_pair in cookie_pairs:
        name_value = cookie_pair.split(&#34;=&#34;)
        if len(name_value) != 2:
            continue
        name, value = unquote(name_value[0].strip()), unquote(name_value[1].strip())
        if name in cookies:
            cookies[name].append(value)
        else:
            cookies[name] = [value]
    return cookies</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="supertokens_python.recipe.session.cookie_and_header.access_token_mutator"><code class="name flex">
<span>def <span class="ident">access_token_mutator</span></span>(<span>access_token: str, front_token: str, config: SessionConfig, transfer_method: TokenTransferMethod, request: BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.anti_csrf_response_mutator"><code class="name flex">
<span>def <span class="ident">anti_csrf_response_mutator</span></span>(<span>value: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.build_front_token"><code class="name flex">
<span>def <span class="ident">build_front_token</span></span>(<span>user_id: str, at_expiry: int, access_token_payload: Optional[Dict[str, Any]] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.clear_session_cookies_from_older_cookie_domain"><code class="name flex">
<span>def <span class="ident">clear_session_cookies_from_older_cookie_domain</span></span>(<span>request: BaseRequest, config: SessionConfig, user_context: Dict[str, Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.clear_session_from_all_token_transfer_methods"><code class="name flex">
<span>def <span class="ident">clear_session_from_all_token_transfer_methods</span></span>(<span>response: BaseResponse, recipe: SessionRecipe, request: BaseRequest, user_context: Dict[str, Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.clear_session_mutator"><code class="name flex">
<span>def <span class="ident">clear_session_mutator</span></span>(<span>config: SessionConfig, transfer_method: TokenTransferMethod, request: BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.clear_session_response_mutator"><code class="name flex">
<span>def <span class="ident">clear_session_response_mutator</span></span>(<span>config: SessionConfig, transfer_method: TokenTransferMethod, request: BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.get_anti_csrf_header"><code class="name flex">
<span>def <span class="ident">get_anti_csrf_header</span></span>(<span>request: BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.get_cookie"><code class="name flex">
<span>def <span class="ident">get_cookie</span></span>(<span>request: BaseRequest, key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.get_cookie_name_from_token_type"><code class="name flex">
<span>def <span class="ident">get_cookie_name_from_token_type</span></span>(<span>token_type: TokenType)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.get_cors_allowed_headers"><code class="name flex">
<span>def <span class="ident">get_cors_allowed_headers</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.get_response_header_name_for_token_type"><code class="name flex">
<span>def <span class="ident">get_response_header_name_for_token_type</span></span>(<span>token_type: TokenType)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.get_rid_header"><code class="name flex">
<span>def <span class="ident">get_rid_header</span></span>(<span>request: BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.get_token"><code class="name flex">
<span>def <span class="ident">get_token</span></span>(<span>request: BaseRequest, token_type: TokenType, transfer_method: TokenTransferMethod)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.has_multiple_cookies_for_token_type"><code class="name flex">
<span>def <span class="ident">has_multiple_cookies_for_token_type</span></span>(<span>request: BaseRequest, token_type: TokenType)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.remove_header"><code class="name flex">
<span>def <span class="ident">remove_header</span></span>(<span>response: BaseResponse, key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.set_cookie_response_mutator"><code class="name flex">
<span>def <span class="ident">set_cookie_response_mutator</span></span>(<span>config: SessionConfig, key: str, value: str, expires: int, path_type: "Literal['refresh_token_path', 'access_token_path']", request: BaseRequest, domain: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.set_header"><code class="name flex">
<span>def <span class="ident">set_header</span></span>(<span>response: BaseResponse, key: str, value: str, allow_duplicate: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.set_token_in_header"><code class="name flex">
<span>def <span class="ident">set_token_in_header</span></span>(<span>response: BaseResponse, name: str, value: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.session.cookie_and_header.token_response_mutator"><code class="name flex">
<span>def <span class="ident">token_response_mutator</span></span>(<span>config: SessionConfig, token_type: TokenType, value: str, expires: int, transfer_method: TokenTransferMethod, request: BaseRequest)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h2>Index</h2>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="supertokens_python.recipe.session" href="index.html">supertokens_python.recipe.session</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.access_token_mutator" href="#supertokens_python.recipe.session.cookie_and_header.access_token_mutator">access_token_mutator</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.anti_csrf_response_mutator" href="#supertokens_python.recipe.session.cookie_and_header.anti_csrf_response_mutator">anti_csrf_response_mutator</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.build_front_token" href="#supertokens_python.recipe.session.cookie_and_header.build_front_token">build_front_token</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.clear_session_cookies_from_older_cookie_domain" href="#supertokens_python.recipe.session.cookie_and_header.clear_session_cookies_from_older_cookie_domain">clear_session_cookies_from_older_cookie_domain</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.clear_session_from_all_token_transfer_methods" href="#supertokens_python.recipe.session.cookie_and_header.clear_session_from_all_token_transfer_methods">clear_session_from_all_token_transfer_methods</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.clear_session_mutator" href="#supertokens_python.recipe.session.cookie_and_header.clear_session_mutator">clear_session_mutator</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.clear_session_response_mutator" href="#supertokens_python.recipe.session.cookie_and_header.clear_session_response_mutator">clear_session_response_mutator</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.get_anti_csrf_header" href="#supertokens_python.recipe.session.cookie_and_header.get_anti_csrf_header">get_anti_csrf_header</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.get_cookie" href="#supertokens_python.recipe.session.cookie_and_header.get_cookie">get_cookie</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.get_cookie_name_from_token_type" href="#supertokens_python.recipe.session.cookie_and_header.get_cookie_name_from_token_type">get_cookie_name_from_token_type</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.get_cors_allowed_headers" href="#supertokens_python.recipe.session.cookie_and_header.get_cors_allowed_headers">get_cors_allowed_headers</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.get_response_header_name_for_token_type" href="#supertokens_python.recipe.session.cookie_and_header.get_response_header_name_for_token_type">get_response_header_name_for_token_type</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.get_rid_header" href="#supertokens_python.recipe.session.cookie_and_header.get_rid_header">get_rid_header</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.get_token" href="#supertokens_python.recipe.session.cookie_and_header.get_token">get_token</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.has_multiple_cookies_for_token_type" href="#supertokens_python.recipe.session.cookie_and_header.has_multiple_cookies_for_token_type">has_multiple_cookies_for_token_type</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.remove_header" href="#supertokens_python.recipe.session.cookie_and_header.remove_header">remove_header</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.set_cookie_response_mutator" href="#supertokens_python.recipe.session.cookie_and_header.set_cookie_response_mutator">set_cookie_response_mutator</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.set_header" href="#supertokens_python.recipe.session.cookie_and_header.set_header">set_header</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.set_token_in_header" href="#supertokens_python.recipe.session.cookie_and_header.set_token_in_header">set_token_in_header</a></code></li>
<li><code><a title="supertokens_python.recipe.session.cookie_and_header.token_response_mutator" href="#supertokens_python.recipe.session.cookie_and_header.token_response_mutator">token_response_mutator</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>

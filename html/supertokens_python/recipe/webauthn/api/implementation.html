<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.0" />
<title>supertokens_python.recipe.webauthn.api.implementation API documentation</title>
<meta name="description" content="Documentation for supertokens_python - SuperTokens Python SDK" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>supertokens_python.recipe.webauthn.api.implementation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2025, VRAI Labs and/or its affiliates. All rights reserved.
#
# This software is licensed under the Apache License, Version 2.0 (the
# &#34;License&#34;) as published by the Apache Software Foundation.
#
# You may not use this file except in compliance with the License. You may
# obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from typing import List, Optional, Union, cast

from typing_extensions import Unpack

from supertokens_python.asyncio import get_user
from supertokens_python.auth_utils import (
    get_authenticating_user_and_add_to_current_tenant_if_required,
    is_fake_email,
    post_auth_checks,
    pre_auth_checks,
)
from supertokens_python.exceptions import raise_general_exception
from supertokens_python.recipe.accountlinking.recipe import AccountLinkingRecipe
from supertokens_python.recipe.accountlinking.types import (
    AccountInfoWithRecipeId,
    AccountInfoWithRecipeIdAndUserId,
    ShouldNotAutomaticallyLink,
)
from supertokens_python.recipe.emailverification.recipe import EmailVerificationRecipe
from supertokens_python.recipe.multifactorauth.asyncio import (
    assert_allowed_to_setup_factor_else_throw_invalid_claim_error,
)
from supertokens_python.recipe.multifactorauth.multi_factor_auth_claim import (
    MultiFactorAuthClaim,
)
from supertokens_python.recipe.multifactorauth.recipe import MultiFactorAuthRecipe
from supertokens_python.recipe.multifactorauth.types import FactorIds
from supertokens_python.recipe.session.interfaces import SessionContainer
from supertokens_python.recipe.webauthn.constants import (
    DEFAULT_REGISTER_OPTIONS_ATTESTATION,
    DEFAULT_REGISTER_OPTIONS_RESIDENT_KEY,
    DEFAULT_REGISTER_OPTIONS_SUPPORTED_ALGORITHM_IDS,
    DEFAULT_REGISTER_OPTIONS_TIMEOUT,
    DEFAULT_REGISTER_OPTIONS_USER_PRESENCE,
    DEFAULT_REGISTER_OPTIONS_USER_VERIFICATION,
    DEFAULT_SIGNIN_OPTIONS_TIMEOUT,
    DEFAULT_SIGNIN_OPTIONS_USER_PRESENCE,
    DEFAULT_SIGNIN_OPTIONS_USER_VERIFICATION,
)
from supertokens_python.recipe.webauthn.interfaces.api import (
    APIInterface,
    APIOptions,
    EmailExistsGetResponse,
    GenerateRecoverAccountTokenPOSTErrorResponse,
    ListCredentialsGETResponse,
    RecoverAccountNotAllowedErrorResponse,
    RecoverAccountPOSTErrorResponse,
    RecoverAccountPOSTResponse,
    RegisterCredentialNotAllowedErrorResponse,
    RegisterCredentialPOSTErrorResponse,
    RegisterOptionsPOSTErrorResponse,
    RegisterOptionsPOSTKwargsInput,
    RegisterOptionsPOSTResponse,
    SignInNotAllowedErrorResponse,
    SignInOptionsPOSTErrorResponse,
    SignInOptionsPOSTResponse,
    SignInPOSTErrorResponse,
    SignInPOSTResponse,
    SignUpNotAllowedErrorResponse,
    SignUpPOSTErrorResponse,
    SignUpPOSTResponse,
    TypeWebauthnEmailDeliveryInput,
    WebauthnRecoverAccountEmailDeliveryUser,
)
from supertokens_python.recipe.webauthn.interfaces.recipe import (
    AuthenticationPayload,
    CredentialNotFoundErrorResponse,
    EmailAlreadyExistsErrorResponse,
    InvalidAuthenticatorErrorResponse,
    InvalidCredentialsErrorResponse,
    InvalidOptionsErrorResponse,
    OptionsNotFoundErrorResponse,
    RecoverAccountTokenInvalidErrorResponse,
    RegistrationPayload,
    UnknownUserIdErrorResponse,
)
from supertokens_python.recipe.webauthn.types.base import (
    WebauthnInfoInput,
)
from supertokens_python.recipe.webauthn.utils import get_recover_account_link
from supertokens_python.types.base import (
    AccountInfoInput,
    LoginMethod,
    RecipeUserId,
    User,
    UserContext,
)
from supertokens_python.types.response import (
    GeneralErrorResponse,
    OkResponseBaseModel,
)
from supertokens_python.utils import (
    get_error_response_reason_from_map,
    log_debug_message,
)


class APIImplementation(APIInterface):
    async def register_options_post(
        self,
        *,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
        **kwargs: Unpack[RegisterOptionsPOSTKwargsInput],
    ) -&gt; Union[
        RegisterOptionsPOSTResponse,
        GeneralErrorResponse,
        RegisterOptionsPOSTErrorResponse,
    ]:
        relying_party_id = await options.config.get_relying_party_id(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        relying_party_name = await options.config.get_relying_party_name(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        origin = await options.config.get_origin(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )

        response = await options.recipe_implementation.register_options(
            **kwargs,
            relying_party_id=relying_party_id,
            relying_party_name=relying_party_name,
            origin=origin,
            resident_key=DEFAULT_REGISTER_OPTIONS_RESIDENT_KEY,
            user_verification=DEFAULT_REGISTER_OPTIONS_USER_VERIFICATION,
            user_presence=DEFAULT_REGISTER_OPTIONS_USER_PRESENCE,
            attestation=DEFAULT_REGISTER_OPTIONS_ATTESTATION,
            supported_algorithm_ids=DEFAULT_REGISTER_OPTIONS_SUPPORTED_ALGORITHM_IDS,
            timeout=DEFAULT_REGISTER_OPTIONS_TIMEOUT,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if response.status != &#34;OK&#34;:
            return response

        return RegisterOptionsPOSTResponse.from_json(response.to_json())

    async def sign_in_options_post(
        self,
        *,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        SignInOptionsPOSTResponse,
        GeneralErrorResponse,
        SignInOptionsPOSTErrorResponse,
    ]:
        relying_party_id = await options.config.get_relying_party_id(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        relying_party_name = await options.config.get_relying_party_name(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        # use this to get the full url instead of only the domain url
        origin = await options.config.get_origin(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )

        response = await options.recipe_implementation.sign_in_options(
            user_verification=DEFAULT_SIGNIN_OPTIONS_USER_VERIFICATION,
            user_presence=DEFAULT_SIGNIN_OPTIONS_USER_PRESENCE,
            origin=origin,
            relying_party_id=relying_party_id,
            relying_party_name=relying_party_name,
            timeout=DEFAULT_SIGNIN_OPTIONS_TIMEOUT,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if response.status != &#34;OK&#34;:
            return response

        return SignInOptionsPOSTResponse.from_json(
            {
                **response.to_json(),
                &#34;rp_id&#34;: relying_party_id,
            }
        )

    async def sign_up_post(
        self,
        *,
        webauthn_generated_options_id: str,
        credential: RegistrationPayload,
        tenant_id: str,
        session: Optional[SessionContainer],
        should_try_linking_with_session_user: Optional[bool],
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[SignUpPOSTResponse, GeneralErrorResponse, SignUpPOSTErrorResponse]:
        error_code_map = {
            &#34;SIGN_UP_NOT_ALLOWED&#34;: &#34;Cannot sign up due to security reasons. Please try logging in, use a different login method or contact support. (ERR_CODE_025)&#34;,
            &#34;LINKING_TO_SESSION_USER_FAILED&#34;: {
                &#34;EMAIL_VERIFICATION_REQUIRED&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_026)&#34;,
                &#34;RECIPE_USER_ID_ALREADY_LINKED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_027)&#34;,
                &#34;ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_028)&#34;,
                &#34;SESSION_USER_ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_029)&#34;,
            },
        }

        generated_options = await options.recipe_implementation.get_generated_options(
            webauthn_generated_options_id=webauthn_generated_options_id,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if generated_options.status != &#34;OK&#34;:
            return generated_options

        email = generated_options.email

        # NOTE: Following checks will likely never throw an error as the
        # check for type is done in a parent function but they are kept
        # here to be on the safe side.
        if not email:
            raise Exception(
                &#34;Should never come here since we already check that the email &#34;
                &#34;value is a string in validate_email_address&#34;
            )

        pre_auth_checks_response = await pre_auth_checks(
            authenticating_account_info=AccountInfoWithRecipeId(
                recipe_id=&#34;webauthn&#34;,
                email=email,
            ),
            factor_ids=[FactorIds.WEBAUTHN],
            is_sign_up=True,
            is_verified=is_fake_email(email),
            sign_in_verifies_login_method=False,
            skip_session_user_update_in_core=False,
            authenticating_user=None,  # since this is a sign up
            tenant_id=tenant_id,
            user_context=user_context,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
        )

        if pre_auth_checks_response.status == &#34;SIGN_UP_NOT_ALLOWED&#34;:
            conflicting_users = await AccountLinkingRecipe.get_instance().recipe_implementation.list_users_by_account_info(
                tenant_id=tenant_id,
                account_info=AccountInfoInput(email=email),
                do_union_of_account_info=False,
                user_context=user_context,
            )

            for user in conflicting_users:
                for login_method in user.login_methods:
                    if (
                        login_method.recipe_id == &#34;webauthn&#34;
                        and login_method.has_same_email_as(email)
                    ):
                        return EmailAlreadyExistsErrorResponse()

        if pre_auth_checks_response.status != &#34;OK&#34;:
            return SignUpNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=pre_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        if is_fake_email(email) and pre_auth_checks_response.is_first_factor:
            # Fake emails cannot be used as a first factor
            return EmailAlreadyExistsErrorResponse()

        sign_up_response = await options.recipe_implementation.sign_up(
            webauthn_generated_options_id=webauthn_generated_options_id,
            credential=credential,
            tenant_id=tenant_id,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
            user_context=user_context,
        )

        if isinstance(
            sign_up_response,
            (
                EmailAlreadyExistsErrorResponse,
                InvalidCredentialsErrorResponse,
                InvalidOptionsErrorResponse,
                OptionsNotFoundErrorResponse,
            ),
        ):
            # We should only return the status, because the core also adds a reason for most of these errors
            return sign_up_response

        if isinstance(sign_up_response, InvalidAuthenticatorErrorResponse):
            return InvalidAuthenticatorErrorResponse(reason=sign_up_response.reason)

        if sign_up_response.status != &#34;OK&#34;:
            return SignUpNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=sign_up_response.status,
                    error_code_map=error_code_map,
                )
            )

        post_auth_checks_response = await post_auth_checks(
            authenticated_user=sign_up_response.user,
            recipe_user_id=sign_up_response.recipe_user_id,
            is_sign_up=True,
            factor_id=FactorIds.WEBAUTHN,
            session=session,
            request=options.req,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if post_auth_checks_response.status != &#34;OK&#34;:
            # It should never actually come here, but we do it cause of consistency.
            # If it does come here (in case there is a bug), it would make this conditional throw
            # anyway, cause there is no SIGN_IN_NOT_ALLOWED in the errorCodeMap.
            return SignUpNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=post_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        return SignUpPOSTResponse(
            session=post_auth_checks_response.session,
            user=post_auth_checks_response.user,
        )

    async def sign_in_post(
        self,
        *,
        webauthn_generated_options_id: str,
        credential: AuthenticationPayload,
        tenant_id: str,
        session: Optional[SessionContainer],
        should_try_linking_with_session_user: Optional[bool],
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[SignInPOSTResponse, GeneralErrorResponse, SignInPOSTErrorResponse]:
        error_code_map = {
            &#34;SIGN_IN_NOT_ALLOWED&#34;: &#34;Cannot sign in due to security reasons. Please try recovering your account, use a different login method or contact support. (ERR_CODE_030)&#34;,
            &#34;LINKING_TO_SESSION_USER_FAILED&#34;: {
                &#34;EMAIL_VERIFICATION_REQUIRED&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_031)&#34;,
                &#34;RECIPE_USER_ID_ALREADY_LINKED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_032)&#34;,
                &#34;ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_033)&#34;,
                &#34;SESSION_USER_ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_034)&#34;,
            },
        }

        verify_result_response = await options.recipe_implementation.verify_credentials(
            credential=credential,
            webauthn_generated_options_id=webauthn_generated_options_id,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if verify_result_response.status != &#34;OK&#34;:
            return InvalidCredentialsErrorResponse()

        generated_options_response = (
            await options.recipe_implementation.get_generated_options(
                webauthn_generated_options_id=webauthn_generated_options_id,
                tenant_id=tenant_id,
                user_context=user_context,
            )
        )

        if generated_options_response.status != &#34;OK&#34;:
            return InvalidCredentialsErrorResponse()

        async def check_credentials_on_tenant(tenant_id: str):
            return True

        authenticating_user = (
            await get_authenticating_user_and_add_to_current_tenant_if_required(
                webauthn=WebauthnInfoInput(credential_id=credential.id),
                user_context=user_context,
                recipe_id=&#34;webauthn&#34;,
                session=session,
                tenant_id=tenant_id,
                check_credentials_on_tenant=check_credentials_on_tenant,
                email=None,
                phone_number=None,
                third_party=None,
            )
        )

        is_verified = (
            authenticating_user is not None
            and authenticating_user.login_method is not None
            and authenticating_user.login_method.verified
        )

        # We check this before preAuthChecks, because that function assumes that if isSignUp is false,
        # then authenticatingUser is defined. While it wouldn&#39;t technically cause any problems with
        # the implementation of that function, this way we can guarantee that either isSignInAllowed or
        # isSignUpAllowed will be called as expected.
        if authenticating_user is None:
            return InvalidCredentialsErrorResponse()

        # We find the email of the user that has the same credentialId as the one we are verifying
        def email_filter(login_method: LoginMethod) -&gt; bool:
            return (
                login_method.recipe_id == &#34;webauthn&#34;
                and login_method.webauthn is not None
                and credential.id in login_method.webauthn.credential_ids
            )

        email = next(filter(email_filter, authenticating_user.user.login_methods), None)
        if email is None or email.email is None:
            raise Exception(&#34;This should never happen: webauthn user has no email&#34;)

        email = email.email

        pre_auth_checks_response = await pre_auth_checks(
            authenticating_account_info=AccountInfoWithRecipeId(
                recipe_id=&#34;webauthn&#34;,
                email=email,
            ),
            factor_ids=[FactorIds.WEBAUTHN],
            is_sign_up=False,
            authenticating_user=authenticating_user.user,
            is_verified=is_verified,
            sign_in_verifies_login_method=False,
            skip_session_user_update_in_core=False,
            tenant_id=tenant_id,
            user_context=user_context,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
        )
        if pre_auth_checks_response.status == &#34;SIGN_IN_NOT_ALLOWED&#34;:
            raise Exception(
                &#34;This should never happen: pre-auth checks should not fail for sign in&#34;
            )
        if pre_auth_checks_response.status != &#34;OK&#34;:
            return SignInNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=pre_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        if is_fake_email(email) and pre_auth_checks_response.is_first_factor:
            # Fake emails cannot be used as a first factor
            return InvalidCredentialsErrorResponse()

        sign_in_response = await options.recipe_implementation.sign_in(
            webauthn_generated_options_id=webauthn_generated_options_id,
            credential=credential,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if isinstance(sign_in_response, InvalidCredentialsErrorResponse):
            return sign_in_response

        if isinstance(
            sign_in_response,
            (
                InvalidOptionsErrorResponse,
                InvalidAuthenticatorErrorResponse,
                CredentialNotFoundErrorResponse,
                UnknownUserIdErrorResponse,
                OptionsNotFoundErrorResponse,
            ),
        ):
            return InvalidCredentialsErrorResponse()

        if sign_in_response.status != &#34;OK&#34;:
            return SignInNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=sign_in_response.status,
                    error_code_map=error_code_map,
                )
            )

        post_auth_checks_response = await post_auth_checks(
            authenticated_user=sign_in_response.user,
            recipe_user_id=sign_in_response.recipe_user_id,
            is_sign_up=False,
            factor_id=FactorIds.WEBAUTHN,
            session=session,
            request=options.req,
            tenant_id=tenant_id,
            user_context=user_context,
        )
        if post_auth_checks_response.status != &#34;OK&#34;:
            return SignInNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=post_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        return SignInPOSTResponse(
            session=post_auth_checks_response.session,
            user=post_auth_checks_response.user,
        )

    async def generate_recover_account_token_post(
        self,
        *,
        email: str,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        OkResponseBaseModel,
        GeneralErrorResponse,
        GenerateRecoverAccountTokenPOSTErrorResponse,
    ]:
        # NOTE: Check for email being a non-string value. This check will likely
        # never evaluate to `true` as there is an upper-level check for the type
        # in validation but kept here to be safe.
        if not isinstance(email, str):  # type: ignore
            raise Exception(
                &#34;Should never come here since we already check that the email &#34;
                &#34;value is a string in validateFormFieldsOrThrowError&#34;
            )

        # This function will be reused in different parts of the flow below.
        async def generate_and_send_recover_account_token(
            primary_user_id: str, recipe_user_id: Optional[RecipeUserId]
        ) -&gt; OkResponseBaseModel:
            # The user ID here can be primary or recipe level
            response = (
                await options.recipe_implementation.generate_recover_account_token(
                    tenant_id=tenant_id,
                    user_id=primary_user_id
                    if recipe_user_id is None
                    else recipe_user_id.get_as_string(),
                    email=email,
                    user_context=user_context,
                )
            )

            if isinstance(response, UnknownUserIdErrorResponse):
                log_debug_message(
                    &#34;Recover account email not sent, unknown user id: &#34;
                    f&#34;{primary_user_id if recipe_user_id is None else recipe_user_id.get_as_string()}&#34;
                )
                return OkResponseBaseModel()

            recover_account_link = get_recover_account_link(
                app_info=options.app_info,
                token=response.token,
                tenant_id=tenant_id,
                request=options.req,
                user_context=user_context,
            )

            log_debug_message(f&#34;Sending recover account email to {email}&#34;)
            await options.email_delivery.ingredient_interface_impl.send_email(
                template_vars=TypeWebauthnEmailDeliveryInput(
                    type=&#34;RECOVER_ACCOUNT&#34;,
                    user=WebauthnRecoverAccountEmailDeliveryUser(
                        id=primary_user_id,
                        recipe_user_id=recipe_user_id,
                        email=email,
                    ),
                    recover_account_link=recover_account_link,
                    tenant_id=tenant_id,
                ),
                user_context=user_context,
            )

            return OkResponseBaseModel()

        # Check if primary_user_id is linked with this email
        users = await AccountLinkingRecipe.get_instance().recipe_implementation.list_users_by_account_info(
            tenant_id=tenant_id,
            account_info=AccountInfoInput(email=email),
            do_union_of_account_info=False,
            user_context=user_context,
        )

        # We find the recipe user ID of the webauthn account from the user&#39;s list for later use
        webauthn_account: Optional[AccountInfoWithRecipeIdAndUserId] = None
        for user in users:
            for login_method in user.login_methods:
                if (
                    login_method.recipe_id == &#34;webauthn&#34;
                    and login_method.has_same_email_as(email)
                ):
                    webauthn_account = AccountInfoWithRecipeIdAndUserId.from_account_info_or_login_method(
                        login_method
                    )
                    break

        # We find the primary user ID from the user&#39;s list for later use
        primary_user_associated_with_email: Optional[User] = None
        for user in users:
            if user.is_primary_user:
                primary_user_associated_with_email = user
                break

        # First we check if there even exists a primary user that has the input email
        # If not, then we do the regular flow for recover account
        if primary_user_associated_with_email is None:
            if webauthn_account is None:
                log_debug_message(
                    f&#34;Recover account email not sent, unknown user email: {email}&#34;
                )
                return OkResponseBaseModel()

            if webauthn_account.recipe_user_id is None:
                raise Exception(
                    &#34;This should never happen: `recipe_user_id` should not be None&#34;
                )

            return await generate_and_send_recover_account_token(
                primary_user_id=webauthn_account.recipe_user_id.get_as_string(),
                recipe_user_id=webauthn_account.recipe_user_id,
            )

        # Next we check if there is any login method in which the input email is verified.
        # If that is the case, then it&#39;s proven that the user owns the email and we can
        # trust linking of the webauthn account.
        email_verified = False
        for login_method in primary_user_associated_with_email.login_methods:
            if login_method.has_same_email_as(email) and login_method.verified:
                email_verified = True
                break

        # Finally, we check if the primary user has any other email / phone number
        # associated with this account - and if it does, then it means that
        # there is a risk of account takeover, so we do not allow the token to be generated
        has_other_email_or_phone = False
        for login_method in primary_user_associated_with_email.login_methods:
            if (
                login_method.email is not None
                and not login_method.has_same_email_as(email)
            ) or (
                login_method.phone_number is not None
                and login_method.phone_number != email
            ):
                has_other_email_or_phone = True
                break

        if not email_verified and has_other_email_or_phone:
            return RecoverAccountNotAllowedErrorResponse(
                reason=(
                    &#34;Recover account link was not created because of account take over risk. &#34;
                    &#34;Please contact support. (ERR_CODE_001)&#34;
                ),
            )

        should_do_account_linking_response = await AccountLinkingRecipe.get_instance().config.should_do_automatic_account_linking(
            webauthn_account
            if webauthn_account is not None
            else AccountInfoWithRecipeIdAndUserId(
                recipe_id=&#34;webauthn&#34;, email=email, recipe_user_id=None
            ),
            primary_user_associated_with_email,
            None,
            tenant_id,
            user_context,
        )

        # Now we need to check that if there exists any webauthn user at all
        # for the input email. If not, then it implies that when the token is consumed,
        # then we will create a new user - so we should only generate the token if
        # the criteria for the new user is met.
        if webauthn_account is None:
            # this means that there is no webauthn user that exists for the input email.
            # So we check for the sign up condition and only go ahead if that condition is
            # met.

            # But first we must check if account linking is enabled at all - cause if it&#39;s
            # not, then the new webauthn user that will be created in recover account
            # code consume cannot be linked to the primary user - therefore, we should
            # not generate a recover account reset token
            if isinstance(
                should_do_account_linking_response, ShouldNotAutomaticallyLink
            ):
                log_debug_message(
                    &#34;Recover account email not sent, since webauthn user didn&#39;t exist, &#34;
                    &#34;and account linking not enabled&#34;
                )
                return OkResponseBaseModel()

            is_sign_up_allowed = await AccountLinkingRecipe.get_instance().is_sign_up_allowed(
                new_user=AccountInfoWithRecipeId(
                    recipe_id=&#34;webauthn&#34;,
                    email=email,
                ),
                is_verified=True,  # Because when the token is consumed, we will mark the email as verified
                session=None,
                tenant_id=tenant_id,
                user_context=user_context,
            )

            if is_sign_up_allowed:
                # Notice that we pass in the primary user ID here. This means that
                # we will be creating a new webauthn account when the token
                # is consumed and linking it to this primary user.
                return await generate_and_send_recover_account_token(
                    primary_user_id=primary_user_associated_with_email.id,
                    recipe_user_id=None,
                )

            log_debug_message(
                f&#34;Recover account email not sent, is_sign_up_allowed returned false for email: {email}&#34;
            )
            return OkResponseBaseModel()

        # At this point, we know that some webauthn user exists with this email
        # and also some primary user ID exist. We now need to find out if they are linked
        # together or not. If they are linked together, then we can just generate the token
        # else we check for more security conditions (since we will be linking them post token generation)
        are_the_two_accounts_linked = False
        for login_method in primary_user_associated_with_email.login_methods:
            # `webauthn_account.recipe_user_id` is guaranteed to be not None
            if (
                login_method.recipe_user_id.get_as_string()
                == webauthn_account.recipe_user_id.get_as_string()  # type: ignore
            ):
                are_the_two_accounts_linked = True
                break

        if are_the_two_accounts_linked:
            return await generate_and_send_recover_account_token(
                primary_user_associated_with_email.id, webauthn_account.recipe_user_id
            )

        # Here we know that the two accounts are NOT linked. We now need to check for an
        # extra security measure here to make sure that the input email in the primary user
        # is verified, and if not, we need to make sure that there is no other email / phone number
        # associated with the primary user account. If there is, then we do not proceed.

        # This security measure helps prevent the following attack:
        # An attacker has email A and they create an account using TP and it doesn&#39;t matter if A is verified or not.
        # Now they create another account using the webauthn with email A and verifies it. Both these accounts are linked.
        # Now the attacker changes the email for webauthn recipe to B which makes the webauthn account unverified, but
        # it&#39;s still linked.

        # If the real owner of B tries to signup using webauthn, it will say that the account already exists so they may
        # try to recover the account which should be denied because then they will end up getting access to attacker&#39;s
        # account and verify the webauthn account.

        # The problem with this situation is if the webauthn account is verified, it will allow further sign-ups with
        # email B which will also be linked to this primary account (that the attacker had created with email A).

        # It is important to realize that the attacker had created another account with A because if they hadn&#39;t done that,
        # then they wouldn&#39;t have access to this account after the real user recovers the account which is why it is
        # important to check there is another non-webauthn account linked to the primary such that the email is not the same as B.

        # Exception to the above is that, if there is a third recipe account linked to the above two accounts and
        # has B as verified, then we should allow recover account token generation because user has already proven that the
        # owns the email B

        # But first, this only matters it the user cares about checking for email verification status.

        if isinstance(should_do_account_linking_response, ShouldNotAutomaticallyLink):
            if webauthn_account.recipe_user_id is None:
                raise Exception(
                    &#34;This should never happen: `recipe_user_id` should not be None&#34;
                )
            # here we will go ahead with the token generation cause
            # even when the token is consumed, we will not be linking the accounts
            # so no need to check for anything
            return await generate_and_send_recover_account_token(
                primary_user_id=webauthn_account.recipe_user_id.get_as_string(),
                recipe_user_id=webauthn_account.recipe_user_id,
            )

        if should_do_account_linking_response.should_require_verification:
            # the checks below are related to email verification, and if the user
            # does not care about that, then we should just continue with token generation
            return await generate_and_send_recover_account_token(
                primary_user_id=primary_user_associated_with_email.id,
                recipe_user_id=webauthn_account.recipe_user_id,
            )

        return await generate_and_send_recover_account_token(
            primary_user_id=primary_user_associated_with_email.id,
            recipe_user_id=webauthn_account.recipe_user_id,
        )

    async def recover_account_post(
        self,
        *,
        token: str,
        webauthn_generated_options_id: str,
        credential: RegistrationPayload,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        RecoverAccountPOSTResponse,
        GeneralErrorResponse,
        RecoverAccountPOSTErrorResponse,
    ]:
        async def mark_email_as_verified(recipe_user_id: RecipeUserId, email: str):
            email_verification_instance = (
                EmailVerificationRecipe.get_instance_optional()
            )
            if email_verification_instance is not None:
                token_response = await email_verification_instance.recipe_implementation.create_email_verification_token(
                    tenant_id=tenant_id,
                    recipe_user_id=recipe_user_id,
                    email=email,
                    user_context=user_context,
                )

                if token_response.status == &#34;OK&#34;:
                    await email_verification_instance.recipe_implementation.verify_email_using_token(
                        tenant_id=tenant_id,
                        token=token_response.token,
                        # We pass a false here since we do account-linking in this API
                        # after this function is called
                        attempt_account_linking=False,
                        user_context=user_context,
                    )

        async def do_register_credential_and_verify_email_and_try_link_if_not_primary(
            recipe_user_id: RecipeUserId,
        ) -&gt; Union[
            RecoverAccountPOSTResponse,
            InvalidCredentialsErrorResponse,
            OptionsNotFoundErrorResponse,
            InvalidOptionsErrorResponse,
            InvalidAuthenticatorErrorResponse,
            GeneralErrorResponse,
        ]:
            update_response = await options.recipe_implementation.register_credential(
                webauthn_generated_options_id=webauthn_generated_options_id,
                credential=credential,
                recipe_user_id=recipe_user_id.get_as_string(),
                user_context=user_context,
            )

            if isinstance(
                update_response,
                (
                    InvalidAuthenticatorErrorResponse,
                    InvalidOptionsErrorResponse,
                    OptionsNotFoundErrorResponse,
                    InvalidCredentialsErrorResponse,
                ),
            ):
                return update_response

            # Status == &#34;OK&#34;
            # If the update was successful, we try to mark the email as verified.
            # We do this because we assume that the recover account token was delivered by email
            # (and to the appropriate email address)
            # so consuming it means that the user actually has access to the emails we send.

            # We only do this if the recover account was successful, otherwise the following scenario is possible:
            # 1. User M: signs up using the email of user V with their own credential. They can&#39;t validate the email,
            #    because it is not their own.
            # 2. User A: tries signing up but sees the email already exists message
            # 3. User A: recovers the account, but somehow this fails
            # If we verified (and linked) the existing user with the original credential, User M would get access to the
            # current user and any linked users.

            await mark_email_as_verified(
                recipe_user_id=recipe_user_id, email=email_for_whom_token_was_generated
            )
            # We refresh the user information here, because the verification status may be updated, which is used during linking.
            updated_user_after_email_verification = await get_user(
                user_id=recipe_user_id.get_as_string(),
                user_context=user_context,
            )
            if updated_user_after_email_verification is None:
                raise Exception(
                    &#34;This should never happen: user deleted during recover account&#34;
                )

            if updated_user_after_email_verification.is_primary_user:
                # If the user is a primary user, we do not need to do any linking
                return RecoverAccountPOSTResponse(
                    user=updated_user_after_email_verification,
                    email=email_for_whom_token_was_generated,
                )

            # If the user is not primary:
            # Now we try and link the accounts.
            # The function below will try and also create a primary user of the new account, this can happen if:
            # 1. the user was unverified and linking requires verification
            # We do not take try linking by session here, since this is supposed to be called without a session
            # Still, the session object is passed around because it is a required input for shouldDoAutomaticAccountLinking
            link_response = await AccountLinkingRecipe.get_instance().try_linking_by_account_info_or_create_primary_user(
                tenant_id=tenant_id,
                input_user=updated_user_after_email_verification,
                session=None,
                user_context=user_context,
            )
            user_after_we_tried_linking = (
                # Explicit cast since we will have a user when the status is OK
                cast(User, link_response.user)
                if link_response.status == &#34;OK&#34;
                else updated_user_after_email_verification
            )
            return RecoverAccountPOSTResponse(
                email=email_for_whom_token_was_generated,
                user=user_after_we_tried_linking,
            )

        token_consumption_response = (
            await options.recipe_implementation.consume_recover_account_token(
                token=token,
                tenant_id=tenant_id,
                user_context=user_context,
            )
        )

        if isinstance(
            token_consumption_response, RecoverAccountTokenInvalidErrorResponse
        ):
            return token_consumption_response

        user_id_for_whom_token_was_generated = token_consumption_response.user_id
        email_for_whom_token_was_generated = token_consumption_response.email

        existing_user = await get_user(
            user_id=token_consumption_response.user_id,
            user_context=user_context,
        )

        if existing_user is None:
            # This should happen only cause of a race condition where the user
            # might be deleted before token creation and consumption.
            # Also note that this being undefined doesn&#39;t mean that the webauthn
            # user does not exist, but it means that there is no recipe or primary user
            # for whom the token was generated.
            return RecoverAccountTokenInvalidErrorResponse()

        if not existing_user.is_primary_user:
            # This means that the existing user is not a primary account, which implies that
            # it must be a non linked webauthn account. In this case, we simply update the credential.
            # Linking to an existing account will be done after the user goes through the email
            # verification flow once they log in (if applicable).
            return await do_register_credential_and_verify_email_and_try_link_if_not_primary(
                recipe_user_id=RecipeUserId(
                    recipe_user_id=user_id_for_whom_token_was_generated
                )
            )

        # User is a primary user
        # If this user contains an webauthn account for whom the token was generated,
        # then we update that user&#39;s credential.
        webauthn_user_is_linked_to_existing_user = False
        for login_method in existing_user.login_methods:
            if (
                login_method.recipe_id == &#34;webauthn&#34;
                and login_method.recipe_user_id.get_as_string()
                == user_id_for_whom_token_was_generated
            ):
                webauthn_user_is_linked_to_existing_user = True
                break

        if webauthn_user_is_linked_to_existing_user:
            return await do_register_credential_and_verify_email_and_try_link_if_not_primary(
                recipe_user_id=RecipeUserId(
                    recipe_user_id=user_id_for_whom_token_was_generated
                )
            )

        # This means that the existingUser does not have an webauthn user associated
        # with it. It could now mean that no webauthn user exists, or it could mean that
        # the the webauthn user exists, but it&#39;s not linked to the current account.
        # If a webauthn user doesn&#39;t exist, we will create one, and link it to the existing account.
        # If webauthn user exists, then it means there is some race condition cause
        # then the token should have been generated for that user instead of the primary user,
        # and it shouldn&#39;t have come into this branch. So we can simply send a recover account
        # invalid error and the user can try again.

        # NOTE: We do not ask the dev if we should do account linking or not here
        # cause we already have asked them this when generating an recover account reset token.
        # In the edge case that the dev changes account linking allowance from true to false
        # when it comes here, only a new recipe user id will be created and not linked
        # cause createPrimaryUserIdOrLinkAccounts will disallow linking. This doesn&#39;t
        # really cause any security issue.
        create_user_response = (
            await options.recipe_implementation.create_new_recipe_user(
                tenant_id=tenant_id,
                webauthn_generated_options_id=webauthn_generated_options_id,
                credential=credential,
                user_context=user_context,
            )
        )

        if isinstance(
            create_user_response,
            (
                InvalidCredentialsErrorResponse,
                OptionsNotFoundErrorResponse,
                InvalidOptionsErrorResponse,
                InvalidAuthenticatorErrorResponse,
            ),
        ):
            return create_user_response

        if isinstance(create_user_response, EmailAlreadyExistsErrorResponse):
            # this means that the user already existed and we can just return an invalid
            # token (see the above comment)
            return RecoverAccountTokenInvalidErrorResponse()

        # we mark the email as verified because recover account also requires
        # access to the email to work.. This has a good side effect that
        # any other login method with the same email in existingAccount will also get marked
        # as verified.
        await mark_email_as_verified(
            recipe_user_id=create_user_response.user.login_methods[0].recipe_user_id,
            email=token_consumption_response.email,
        )
        updated_user = await get_user(
            user_id=create_user_response.user.id, user_context=user_context
        )
        if updated_user is None:
            raise Exception(
                &#34;This should never happen: user deleted during recover account&#34;
            )
        create_user_response.user = updated_user

        # Now we try and link the accounts. The function below will try and also
        # create a primary user of the new account, and if it does that, it&#39;s OK..
        # But in most cases, it will end up linking to existing account since the
        # email is shared.
        # We do not take try linking by session here, since this is supposed to be called without a session
        # Still, the session object is passed around because it is a required input for shouldDoAutomaticAccountLinking
        link_response = await AccountLinkingRecipe.get_instance().try_linking_by_account_info_or_create_primary_user(
            tenant_id=tenant_id,
            input_user=create_user_response.user,
            session=None,
            user_context=user_context,
        )

        # Link response user will always be non-None if status == &#34;OK&#34;
        user_after_linking = (
            cast(User, link_response.user)
            if link_response.status == &#34;OK&#34;
            else create_user_response.user
        )

        if (
            link_response.status == &#34;OK&#34;
            and cast(User, link_response.user).id != existing_user.id
        ):
            # this means that the account we just linked to
            # was not the one we had expected to link it to. This can happen
            # due to some race condition or the other.. Either way, this
            # is not an issue and we can just return OK
            pass

        return RecoverAccountPOSTResponse(
            email=token_consumption_response.email,
            user=user_after_linking,
        )

    async def list_credentials_get(
        self,
        *,
        options: APIOptions,
        user_context: UserContext,
        session: SessionContainer,
    ) -&gt; ListCredentialsGETResponse:
        existing_user = await get_user(
            user_id=session.get_user_id(),
            user_context=user_context,
        )
        if existing_user is None:
            raise_general_exception(&#34;User not found&#34;)

        recipe_user_ids = [
            lm.recipe_user_id
            for lm in existing_user.login_methods
            if lm.recipe_id == &#34;webauthn&#34;
        ]

        credentials: List[ListCredentialsGETResponse.Credential] = []

        for recipe_user_id in recipe_user_ids:
            list_credentials_response = (
                await options.recipe_implementation.list_credentials(
                    recipe_user_id=recipe_user_id.get_as_string(),
                    user_context=user_context,
                )
            )

            credentials.extend(list_credentials_response.credentials)

        return ListCredentialsGETResponse(
            credentials=credentials,
        )

    async def register_credential_post(
        self,
        *,
        webauthn_generated_options_id: str,
        credential: RegistrationPayload,
        tenant_id: str,
        session: SessionContainer,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        OkResponseBaseModel,
        GeneralErrorResponse,
        RegisterCredentialPOSTErrorResponse,
    ]:
        error_code_map = {
            &#34;REGISTER_CREDENTIAL_NOT_ALLOWED&#34;: &#34;Cannot register credential due to security reasons. Please try logging in, use a different login method or contact support. (ERR_CODE_007)&#34;,
            &#34;INVALID_AUTHENTICATOR_ERROR&#34;: &#34;The device used for authentication is not supported. Please use a different device. (ERR_CODE_026)&#34;,
            &#34;INVALID_CREDENTIALS_ERROR&#34;: &#34;The credentials are incorrect. Please make sure you are using the correct credentials. (ERR_CODE_025)&#34;,
        }

        mfa_instance = MultiFactorAuthRecipe.get_instance()
        if mfa_instance is not None:
            await assert_allowed_to_setup_factor_else_throw_invalid_claim_error(
                session=session,
                factor_id=FactorIds.WEBAUTHN,
                user_context=user_context,
            )

        generated_options = await options.recipe_implementation.get_generated_options(
            webauthn_generated_options_id=webauthn_generated_options_id,
            tenant_id=tenant_id,
            user_context=user_context,
        )
        if generated_options.status != &#34;OK&#34;:
            return generated_options

        email = generated_options.email
        # NOTE: Following checks will likely never throw an error as the
        # check for type is done in a parent function but they are kept
        # here to be on the safe side.
        if not isinstance(email, str):  # type: ignore
            raise Exception(
                &#34;Should never come here since we already check that the email &#34;
                &#34;value is a string in validate_email_address&#34;
            )

        register_credential_response = (
            await options.recipe_implementation.register_credential(
                webauthn_generated_options_id=webauthn_generated_options_id,
                credential=credential,
                user_context=user_context,
                recipe_user_id=session.get_recipe_user_id().get_as_string(),
            )
        )

        if register_credential_response.status != &#34;OK&#34;:
            return RegisterCredentialNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=register_credential_response.status,
                    error_code_map=error_code_map,
                )
            )

        return OkResponseBaseModel()

    async def remove_credential_post(
        self,
        *,
        webauthn_credential_id: str,
        session: SessionContainer,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        OkResponseBaseModel, GeneralErrorResponse, CredentialNotFoundErrorResponse
    ]:
        mfa_instance = MultiFactorAuthRecipe.get_instance()
        if mfa_instance is not None:
            await session.assert_claims(
                claim_validators=[
                    MultiFactorAuthClaim.validators.has_completed_mfa_requirements_for_auth()
                ]
            )

        user = await get_user(session.get_user_id(), user_context=user_context)
        if user is None:
            raise_general_exception(&#34;User not found&#34;)

        required_login_methods = [
            lm
            for lm in user.login_methods
            if lm.recipe_id == &#34;webauthn&#34;
            and lm.webauthn is not None
            and webauthn_credential_id in lm.webauthn.credential_ids
        ]
        if len(required_login_methods) == 0:
            raise_general_exception(&#34;User not found&#34;)

        recipe_user_id = required_login_methods[0].recipe_user_id

        remove_credential_response = (
            await options.recipe_implementation.remove_credential(
                webauthn_credential_id=webauthn_credential_id,
                recipe_user_id=recipe_user_id.get_as_string(),
                user_context=user_context,
            )
        )

        if remove_credential_response.status != &#34;OK&#34;:
            return remove_credential_response

        return OkResponseBaseModel()

    async def email_exists_get(
        self,
        *,
        email: str,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[EmailExistsGetResponse, GeneralErrorResponse]:
        users = await AccountLinkingRecipe.get_instance().recipe_implementation.list_users_by_account_info(
            tenant_id=tenant_id,
            account_info=AccountInfoInput(email=email),
            do_union_of_account_info=False,
            user_context=user_context,
        )

        webauthn_user_exists = False
        for user in users:
            for login_method in user.login_methods:
                if (
                    login_method.recipe_id == &#34;webauthn&#34;
                    and login_method.has_same_email_as(email)
                ):
                    webauthn_user_exists = True
                    break

        return EmailExistsGetResponse(exists=webauthn_user_exists)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation"><code class="flex name class">
<span>class <span class="ident">APIImplementation</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class APIImplementation(APIInterface):
    async def register_options_post(
        self,
        *,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
        **kwargs: Unpack[RegisterOptionsPOSTKwargsInput],
    ) -&gt; Union[
        RegisterOptionsPOSTResponse,
        GeneralErrorResponse,
        RegisterOptionsPOSTErrorResponse,
    ]:
        relying_party_id = await options.config.get_relying_party_id(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        relying_party_name = await options.config.get_relying_party_name(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        origin = await options.config.get_origin(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )

        response = await options.recipe_implementation.register_options(
            **kwargs,
            relying_party_id=relying_party_id,
            relying_party_name=relying_party_name,
            origin=origin,
            resident_key=DEFAULT_REGISTER_OPTIONS_RESIDENT_KEY,
            user_verification=DEFAULT_REGISTER_OPTIONS_USER_VERIFICATION,
            user_presence=DEFAULT_REGISTER_OPTIONS_USER_PRESENCE,
            attestation=DEFAULT_REGISTER_OPTIONS_ATTESTATION,
            supported_algorithm_ids=DEFAULT_REGISTER_OPTIONS_SUPPORTED_ALGORITHM_IDS,
            timeout=DEFAULT_REGISTER_OPTIONS_TIMEOUT,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if response.status != &#34;OK&#34;:
            return response

        return RegisterOptionsPOSTResponse.from_json(response.to_json())

    async def sign_in_options_post(
        self,
        *,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        SignInOptionsPOSTResponse,
        GeneralErrorResponse,
        SignInOptionsPOSTErrorResponse,
    ]:
        relying_party_id = await options.config.get_relying_party_id(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        relying_party_name = await options.config.get_relying_party_name(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )
        # use this to get the full url instead of only the domain url
        origin = await options.config.get_origin(
            tenant_id=tenant_id,
            request=options.req,
            user_context=user_context,
        )

        response = await options.recipe_implementation.sign_in_options(
            user_verification=DEFAULT_SIGNIN_OPTIONS_USER_VERIFICATION,
            user_presence=DEFAULT_SIGNIN_OPTIONS_USER_PRESENCE,
            origin=origin,
            relying_party_id=relying_party_id,
            relying_party_name=relying_party_name,
            timeout=DEFAULT_SIGNIN_OPTIONS_TIMEOUT,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if response.status != &#34;OK&#34;:
            return response

        return SignInOptionsPOSTResponse.from_json(
            {
                **response.to_json(),
                &#34;rp_id&#34;: relying_party_id,
            }
        )

    async def sign_up_post(
        self,
        *,
        webauthn_generated_options_id: str,
        credential: RegistrationPayload,
        tenant_id: str,
        session: Optional[SessionContainer],
        should_try_linking_with_session_user: Optional[bool],
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[SignUpPOSTResponse, GeneralErrorResponse, SignUpPOSTErrorResponse]:
        error_code_map = {
            &#34;SIGN_UP_NOT_ALLOWED&#34;: &#34;Cannot sign up due to security reasons. Please try logging in, use a different login method or contact support. (ERR_CODE_025)&#34;,
            &#34;LINKING_TO_SESSION_USER_FAILED&#34;: {
                &#34;EMAIL_VERIFICATION_REQUIRED&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_026)&#34;,
                &#34;RECIPE_USER_ID_ALREADY_LINKED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_027)&#34;,
                &#34;ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_028)&#34;,
                &#34;SESSION_USER_ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_029)&#34;,
            },
        }

        generated_options = await options.recipe_implementation.get_generated_options(
            webauthn_generated_options_id=webauthn_generated_options_id,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if generated_options.status != &#34;OK&#34;:
            return generated_options

        email = generated_options.email

        # NOTE: Following checks will likely never throw an error as the
        # check for type is done in a parent function but they are kept
        # here to be on the safe side.
        if not email:
            raise Exception(
                &#34;Should never come here since we already check that the email &#34;
                &#34;value is a string in validate_email_address&#34;
            )

        pre_auth_checks_response = await pre_auth_checks(
            authenticating_account_info=AccountInfoWithRecipeId(
                recipe_id=&#34;webauthn&#34;,
                email=email,
            ),
            factor_ids=[FactorIds.WEBAUTHN],
            is_sign_up=True,
            is_verified=is_fake_email(email),
            sign_in_verifies_login_method=False,
            skip_session_user_update_in_core=False,
            authenticating_user=None,  # since this is a sign up
            tenant_id=tenant_id,
            user_context=user_context,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
        )

        if pre_auth_checks_response.status == &#34;SIGN_UP_NOT_ALLOWED&#34;:
            conflicting_users = await AccountLinkingRecipe.get_instance().recipe_implementation.list_users_by_account_info(
                tenant_id=tenant_id,
                account_info=AccountInfoInput(email=email),
                do_union_of_account_info=False,
                user_context=user_context,
            )

            for user in conflicting_users:
                for login_method in user.login_methods:
                    if (
                        login_method.recipe_id == &#34;webauthn&#34;
                        and login_method.has_same_email_as(email)
                    ):
                        return EmailAlreadyExistsErrorResponse()

        if pre_auth_checks_response.status != &#34;OK&#34;:
            return SignUpNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=pre_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        if is_fake_email(email) and pre_auth_checks_response.is_first_factor:
            # Fake emails cannot be used as a first factor
            return EmailAlreadyExistsErrorResponse()

        sign_up_response = await options.recipe_implementation.sign_up(
            webauthn_generated_options_id=webauthn_generated_options_id,
            credential=credential,
            tenant_id=tenant_id,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
            user_context=user_context,
        )

        if isinstance(
            sign_up_response,
            (
                EmailAlreadyExistsErrorResponse,
                InvalidCredentialsErrorResponse,
                InvalidOptionsErrorResponse,
                OptionsNotFoundErrorResponse,
            ),
        ):
            # We should only return the status, because the core also adds a reason for most of these errors
            return sign_up_response

        if isinstance(sign_up_response, InvalidAuthenticatorErrorResponse):
            return InvalidAuthenticatorErrorResponse(reason=sign_up_response.reason)

        if sign_up_response.status != &#34;OK&#34;:
            return SignUpNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=sign_up_response.status,
                    error_code_map=error_code_map,
                )
            )

        post_auth_checks_response = await post_auth_checks(
            authenticated_user=sign_up_response.user,
            recipe_user_id=sign_up_response.recipe_user_id,
            is_sign_up=True,
            factor_id=FactorIds.WEBAUTHN,
            session=session,
            request=options.req,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if post_auth_checks_response.status != &#34;OK&#34;:
            # It should never actually come here, but we do it cause of consistency.
            # If it does come here (in case there is a bug), it would make this conditional throw
            # anyway, cause there is no SIGN_IN_NOT_ALLOWED in the errorCodeMap.
            return SignUpNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=post_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        return SignUpPOSTResponse(
            session=post_auth_checks_response.session,
            user=post_auth_checks_response.user,
        )

    async def sign_in_post(
        self,
        *,
        webauthn_generated_options_id: str,
        credential: AuthenticationPayload,
        tenant_id: str,
        session: Optional[SessionContainer],
        should_try_linking_with_session_user: Optional[bool],
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[SignInPOSTResponse, GeneralErrorResponse, SignInPOSTErrorResponse]:
        error_code_map = {
            &#34;SIGN_IN_NOT_ALLOWED&#34;: &#34;Cannot sign in due to security reasons. Please try recovering your account, use a different login method or contact support. (ERR_CODE_030)&#34;,
            &#34;LINKING_TO_SESSION_USER_FAILED&#34;: {
                &#34;EMAIL_VERIFICATION_REQUIRED&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_031)&#34;,
                &#34;RECIPE_USER_ID_ALREADY_LINKED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_032)&#34;,
                &#34;ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_033)&#34;,
                &#34;SESSION_USER_ACCOUNT_INFO_ALREADY_ASSOCIATED_WITH_ANOTHER_PRIMARY_USER_ID_ERROR&#34;: &#34;Cannot sign in / up due to security reasons. Please contact support. (ERR_CODE_034)&#34;,
            },
        }

        verify_result_response = await options.recipe_implementation.verify_credentials(
            credential=credential,
            webauthn_generated_options_id=webauthn_generated_options_id,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if verify_result_response.status != &#34;OK&#34;:
            return InvalidCredentialsErrorResponse()

        generated_options_response = (
            await options.recipe_implementation.get_generated_options(
                webauthn_generated_options_id=webauthn_generated_options_id,
                tenant_id=tenant_id,
                user_context=user_context,
            )
        )

        if generated_options_response.status != &#34;OK&#34;:
            return InvalidCredentialsErrorResponse()

        async def check_credentials_on_tenant(tenant_id: str):
            return True

        authenticating_user = (
            await get_authenticating_user_and_add_to_current_tenant_if_required(
                webauthn=WebauthnInfoInput(credential_id=credential.id),
                user_context=user_context,
                recipe_id=&#34;webauthn&#34;,
                session=session,
                tenant_id=tenant_id,
                check_credentials_on_tenant=check_credentials_on_tenant,
                email=None,
                phone_number=None,
                third_party=None,
            )
        )

        is_verified = (
            authenticating_user is not None
            and authenticating_user.login_method is not None
            and authenticating_user.login_method.verified
        )

        # We check this before preAuthChecks, because that function assumes that if isSignUp is false,
        # then authenticatingUser is defined. While it wouldn&#39;t technically cause any problems with
        # the implementation of that function, this way we can guarantee that either isSignInAllowed or
        # isSignUpAllowed will be called as expected.
        if authenticating_user is None:
            return InvalidCredentialsErrorResponse()

        # We find the email of the user that has the same credentialId as the one we are verifying
        def email_filter(login_method: LoginMethod) -&gt; bool:
            return (
                login_method.recipe_id == &#34;webauthn&#34;
                and login_method.webauthn is not None
                and credential.id in login_method.webauthn.credential_ids
            )

        email = next(filter(email_filter, authenticating_user.user.login_methods), None)
        if email is None or email.email is None:
            raise Exception(&#34;This should never happen: webauthn user has no email&#34;)

        email = email.email

        pre_auth_checks_response = await pre_auth_checks(
            authenticating_account_info=AccountInfoWithRecipeId(
                recipe_id=&#34;webauthn&#34;,
                email=email,
            ),
            factor_ids=[FactorIds.WEBAUTHN],
            is_sign_up=False,
            authenticating_user=authenticating_user.user,
            is_verified=is_verified,
            sign_in_verifies_login_method=False,
            skip_session_user_update_in_core=False,
            tenant_id=tenant_id,
            user_context=user_context,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
        )
        if pre_auth_checks_response.status == &#34;SIGN_IN_NOT_ALLOWED&#34;:
            raise Exception(
                &#34;This should never happen: pre-auth checks should not fail for sign in&#34;
            )
        if pre_auth_checks_response.status != &#34;OK&#34;:
            return SignInNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=pre_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        if is_fake_email(email) and pre_auth_checks_response.is_first_factor:
            # Fake emails cannot be used as a first factor
            return InvalidCredentialsErrorResponse()

        sign_in_response = await options.recipe_implementation.sign_in(
            webauthn_generated_options_id=webauthn_generated_options_id,
            credential=credential,
            session=session,
            should_try_linking_with_session_user=should_try_linking_with_session_user,
            tenant_id=tenant_id,
            user_context=user_context,
        )

        if isinstance(sign_in_response, InvalidCredentialsErrorResponse):
            return sign_in_response

        if isinstance(
            sign_in_response,
            (
                InvalidOptionsErrorResponse,
                InvalidAuthenticatorErrorResponse,
                CredentialNotFoundErrorResponse,
                UnknownUserIdErrorResponse,
                OptionsNotFoundErrorResponse,
            ),
        ):
            return InvalidCredentialsErrorResponse()

        if sign_in_response.status != &#34;OK&#34;:
            return SignInNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=sign_in_response.status,
                    error_code_map=error_code_map,
                )
            )

        post_auth_checks_response = await post_auth_checks(
            authenticated_user=sign_in_response.user,
            recipe_user_id=sign_in_response.recipe_user_id,
            is_sign_up=False,
            factor_id=FactorIds.WEBAUTHN,
            session=session,
            request=options.req,
            tenant_id=tenant_id,
            user_context=user_context,
        )
        if post_auth_checks_response.status != &#34;OK&#34;:
            return SignInNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=post_auth_checks_response.status,
                    error_code_map=error_code_map,
                )
            )

        return SignInPOSTResponse(
            session=post_auth_checks_response.session,
            user=post_auth_checks_response.user,
        )

    async def generate_recover_account_token_post(
        self,
        *,
        email: str,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        OkResponseBaseModel,
        GeneralErrorResponse,
        GenerateRecoverAccountTokenPOSTErrorResponse,
    ]:
        # NOTE: Check for email being a non-string value. This check will likely
        # never evaluate to `true` as there is an upper-level check for the type
        # in validation but kept here to be safe.
        if not isinstance(email, str):  # type: ignore
            raise Exception(
                &#34;Should never come here since we already check that the email &#34;
                &#34;value is a string in validateFormFieldsOrThrowError&#34;
            )

        # This function will be reused in different parts of the flow below.
        async def generate_and_send_recover_account_token(
            primary_user_id: str, recipe_user_id: Optional[RecipeUserId]
        ) -&gt; OkResponseBaseModel:
            # The user ID here can be primary or recipe level
            response = (
                await options.recipe_implementation.generate_recover_account_token(
                    tenant_id=tenant_id,
                    user_id=primary_user_id
                    if recipe_user_id is None
                    else recipe_user_id.get_as_string(),
                    email=email,
                    user_context=user_context,
                )
            )

            if isinstance(response, UnknownUserIdErrorResponse):
                log_debug_message(
                    &#34;Recover account email not sent, unknown user id: &#34;
                    f&#34;{primary_user_id if recipe_user_id is None else recipe_user_id.get_as_string()}&#34;
                )
                return OkResponseBaseModel()

            recover_account_link = get_recover_account_link(
                app_info=options.app_info,
                token=response.token,
                tenant_id=tenant_id,
                request=options.req,
                user_context=user_context,
            )

            log_debug_message(f&#34;Sending recover account email to {email}&#34;)
            await options.email_delivery.ingredient_interface_impl.send_email(
                template_vars=TypeWebauthnEmailDeliveryInput(
                    type=&#34;RECOVER_ACCOUNT&#34;,
                    user=WebauthnRecoverAccountEmailDeliveryUser(
                        id=primary_user_id,
                        recipe_user_id=recipe_user_id,
                        email=email,
                    ),
                    recover_account_link=recover_account_link,
                    tenant_id=tenant_id,
                ),
                user_context=user_context,
            )

            return OkResponseBaseModel()

        # Check if primary_user_id is linked with this email
        users = await AccountLinkingRecipe.get_instance().recipe_implementation.list_users_by_account_info(
            tenant_id=tenant_id,
            account_info=AccountInfoInput(email=email),
            do_union_of_account_info=False,
            user_context=user_context,
        )

        # We find the recipe user ID of the webauthn account from the user&#39;s list for later use
        webauthn_account: Optional[AccountInfoWithRecipeIdAndUserId] = None
        for user in users:
            for login_method in user.login_methods:
                if (
                    login_method.recipe_id == &#34;webauthn&#34;
                    and login_method.has_same_email_as(email)
                ):
                    webauthn_account = AccountInfoWithRecipeIdAndUserId.from_account_info_or_login_method(
                        login_method
                    )
                    break

        # We find the primary user ID from the user&#39;s list for later use
        primary_user_associated_with_email: Optional[User] = None
        for user in users:
            if user.is_primary_user:
                primary_user_associated_with_email = user
                break

        # First we check if there even exists a primary user that has the input email
        # If not, then we do the regular flow for recover account
        if primary_user_associated_with_email is None:
            if webauthn_account is None:
                log_debug_message(
                    f&#34;Recover account email not sent, unknown user email: {email}&#34;
                )
                return OkResponseBaseModel()

            if webauthn_account.recipe_user_id is None:
                raise Exception(
                    &#34;This should never happen: `recipe_user_id` should not be None&#34;
                )

            return await generate_and_send_recover_account_token(
                primary_user_id=webauthn_account.recipe_user_id.get_as_string(),
                recipe_user_id=webauthn_account.recipe_user_id,
            )

        # Next we check if there is any login method in which the input email is verified.
        # If that is the case, then it&#39;s proven that the user owns the email and we can
        # trust linking of the webauthn account.
        email_verified = False
        for login_method in primary_user_associated_with_email.login_methods:
            if login_method.has_same_email_as(email) and login_method.verified:
                email_verified = True
                break

        # Finally, we check if the primary user has any other email / phone number
        # associated with this account - and if it does, then it means that
        # there is a risk of account takeover, so we do not allow the token to be generated
        has_other_email_or_phone = False
        for login_method in primary_user_associated_with_email.login_methods:
            if (
                login_method.email is not None
                and not login_method.has_same_email_as(email)
            ) or (
                login_method.phone_number is not None
                and login_method.phone_number != email
            ):
                has_other_email_or_phone = True
                break

        if not email_verified and has_other_email_or_phone:
            return RecoverAccountNotAllowedErrorResponse(
                reason=(
                    &#34;Recover account link was not created because of account take over risk. &#34;
                    &#34;Please contact support. (ERR_CODE_001)&#34;
                ),
            )

        should_do_account_linking_response = await AccountLinkingRecipe.get_instance().config.should_do_automatic_account_linking(
            webauthn_account
            if webauthn_account is not None
            else AccountInfoWithRecipeIdAndUserId(
                recipe_id=&#34;webauthn&#34;, email=email, recipe_user_id=None
            ),
            primary_user_associated_with_email,
            None,
            tenant_id,
            user_context,
        )

        # Now we need to check that if there exists any webauthn user at all
        # for the input email. If not, then it implies that when the token is consumed,
        # then we will create a new user - so we should only generate the token if
        # the criteria for the new user is met.
        if webauthn_account is None:
            # this means that there is no webauthn user that exists for the input email.
            # So we check for the sign up condition and only go ahead if that condition is
            # met.

            # But first we must check if account linking is enabled at all - cause if it&#39;s
            # not, then the new webauthn user that will be created in recover account
            # code consume cannot be linked to the primary user - therefore, we should
            # not generate a recover account reset token
            if isinstance(
                should_do_account_linking_response, ShouldNotAutomaticallyLink
            ):
                log_debug_message(
                    &#34;Recover account email not sent, since webauthn user didn&#39;t exist, &#34;
                    &#34;and account linking not enabled&#34;
                )
                return OkResponseBaseModel()

            is_sign_up_allowed = await AccountLinkingRecipe.get_instance().is_sign_up_allowed(
                new_user=AccountInfoWithRecipeId(
                    recipe_id=&#34;webauthn&#34;,
                    email=email,
                ),
                is_verified=True,  # Because when the token is consumed, we will mark the email as verified
                session=None,
                tenant_id=tenant_id,
                user_context=user_context,
            )

            if is_sign_up_allowed:
                # Notice that we pass in the primary user ID here. This means that
                # we will be creating a new webauthn account when the token
                # is consumed and linking it to this primary user.
                return await generate_and_send_recover_account_token(
                    primary_user_id=primary_user_associated_with_email.id,
                    recipe_user_id=None,
                )

            log_debug_message(
                f&#34;Recover account email not sent, is_sign_up_allowed returned false for email: {email}&#34;
            )
            return OkResponseBaseModel()

        # At this point, we know that some webauthn user exists with this email
        # and also some primary user ID exist. We now need to find out if they are linked
        # together or not. If they are linked together, then we can just generate the token
        # else we check for more security conditions (since we will be linking them post token generation)
        are_the_two_accounts_linked = False
        for login_method in primary_user_associated_with_email.login_methods:
            # `webauthn_account.recipe_user_id` is guaranteed to be not None
            if (
                login_method.recipe_user_id.get_as_string()
                == webauthn_account.recipe_user_id.get_as_string()  # type: ignore
            ):
                are_the_two_accounts_linked = True
                break

        if are_the_two_accounts_linked:
            return await generate_and_send_recover_account_token(
                primary_user_associated_with_email.id, webauthn_account.recipe_user_id
            )

        # Here we know that the two accounts are NOT linked. We now need to check for an
        # extra security measure here to make sure that the input email in the primary user
        # is verified, and if not, we need to make sure that there is no other email / phone number
        # associated with the primary user account. If there is, then we do not proceed.

        # This security measure helps prevent the following attack:
        # An attacker has email A and they create an account using TP and it doesn&#39;t matter if A is verified or not.
        # Now they create another account using the webauthn with email A and verifies it. Both these accounts are linked.
        # Now the attacker changes the email for webauthn recipe to B which makes the webauthn account unverified, but
        # it&#39;s still linked.

        # If the real owner of B tries to signup using webauthn, it will say that the account already exists so they may
        # try to recover the account which should be denied because then they will end up getting access to attacker&#39;s
        # account and verify the webauthn account.

        # The problem with this situation is if the webauthn account is verified, it will allow further sign-ups with
        # email B which will also be linked to this primary account (that the attacker had created with email A).

        # It is important to realize that the attacker had created another account with A because if they hadn&#39;t done that,
        # then they wouldn&#39;t have access to this account after the real user recovers the account which is why it is
        # important to check there is another non-webauthn account linked to the primary such that the email is not the same as B.

        # Exception to the above is that, if there is a third recipe account linked to the above two accounts and
        # has B as verified, then we should allow recover account token generation because user has already proven that the
        # owns the email B

        # But first, this only matters it the user cares about checking for email verification status.

        if isinstance(should_do_account_linking_response, ShouldNotAutomaticallyLink):
            if webauthn_account.recipe_user_id is None:
                raise Exception(
                    &#34;This should never happen: `recipe_user_id` should not be None&#34;
                )
            # here we will go ahead with the token generation cause
            # even when the token is consumed, we will not be linking the accounts
            # so no need to check for anything
            return await generate_and_send_recover_account_token(
                primary_user_id=webauthn_account.recipe_user_id.get_as_string(),
                recipe_user_id=webauthn_account.recipe_user_id,
            )

        if should_do_account_linking_response.should_require_verification:
            # the checks below are related to email verification, and if the user
            # does not care about that, then we should just continue with token generation
            return await generate_and_send_recover_account_token(
                primary_user_id=primary_user_associated_with_email.id,
                recipe_user_id=webauthn_account.recipe_user_id,
            )

        return await generate_and_send_recover_account_token(
            primary_user_id=primary_user_associated_with_email.id,
            recipe_user_id=webauthn_account.recipe_user_id,
        )

    async def recover_account_post(
        self,
        *,
        token: str,
        webauthn_generated_options_id: str,
        credential: RegistrationPayload,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        RecoverAccountPOSTResponse,
        GeneralErrorResponse,
        RecoverAccountPOSTErrorResponse,
    ]:
        async def mark_email_as_verified(recipe_user_id: RecipeUserId, email: str):
            email_verification_instance = (
                EmailVerificationRecipe.get_instance_optional()
            )
            if email_verification_instance is not None:
                token_response = await email_verification_instance.recipe_implementation.create_email_verification_token(
                    tenant_id=tenant_id,
                    recipe_user_id=recipe_user_id,
                    email=email,
                    user_context=user_context,
                )

                if token_response.status == &#34;OK&#34;:
                    await email_verification_instance.recipe_implementation.verify_email_using_token(
                        tenant_id=tenant_id,
                        token=token_response.token,
                        # We pass a false here since we do account-linking in this API
                        # after this function is called
                        attempt_account_linking=False,
                        user_context=user_context,
                    )

        async def do_register_credential_and_verify_email_and_try_link_if_not_primary(
            recipe_user_id: RecipeUserId,
        ) -&gt; Union[
            RecoverAccountPOSTResponse,
            InvalidCredentialsErrorResponse,
            OptionsNotFoundErrorResponse,
            InvalidOptionsErrorResponse,
            InvalidAuthenticatorErrorResponse,
            GeneralErrorResponse,
        ]:
            update_response = await options.recipe_implementation.register_credential(
                webauthn_generated_options_id=webauthn_generated_options_id,
                credential=credential,
                recipe_user_id=recipe_user_id.get_as_string(),
                user_context=user_context,
            )

            if isinstance(
                update_response,
                (
                    InvalidAuthenticatorErrorResponse,
                    InvalidOptionsErrorResponse,
                    OptionsNotFoundErrorResponse,
                    InvalidCredentialsErrorResponse,
                ),
            ):
                return update_response

            # Status == &#34;OK&#34;
            # If the update was successful, we try to mark the email as verified.
            # We do this because we assume that the recover account token was delivered by email
            # (and to the appropriate email address)
            # so consuming it means that the user actually has access to the emails we send.

            # We only do this if the recover account was successful, otherwise the following scenario is possible:
            # 1. User M: signs up using the email of user V with their own credential. They can&#39;t validate the email,
            #    because it is not their own.
            # 2. User A: tries signing up but sees the email already exists message
            # 3. User A: recovers the account, but somehow this fails
            # If we verified (and linked) the existing user with the original credential, User M would get access to the
            # current user and any linked users.

            await mark_email_as_verified(
                recipe_user_id=recipe_user_id, email=email_for_whom_token_was_generated
            )
            # We refresh the user information here, because the verification status may be updated, which is used during linking.
            updated_user_after_email_verification = await get_user(
                user_id=recipe_user_id.get_as_string(),
                user_context=user_context,
            )
            if updated_user_after_email_verification is None:
                raise Exception(
                    &#34;This should never happen: user deleted during recover account&#34;
                )

            if updated_user_after_email_verification.is_primary_user:
                # If the user is a primary user, we do not need to do any linking
                return RecoverAccountPOSTResponse(
                    user=updated_user_after_email_verification,
                    email=email_for_whom_token_was_generated,
                )

            # If the user is not primary:
            # Now we try and link the accounts.
            # The function below will try and also create a primary user of the new account, this can happen if:
            # 1. the user was unverified and linking requires verification
            # We do not take try linking by session here, since this is supposed to be called without a session
            # Still, the session object is passed around because it is a required input for shouldDoAutomaticAccountLinking
            link_response = await AccountLinkingRecipe.get_instance().try_linking_by_account_info_or_create_primary_user(
                tenant_id=tenant_id,
                input_user=updated_user_after_email_verification,
                session=None,
                user_context=user_context,
            )
            user_after_we_tried_linking = (
                # Explicit cast since we will have a user when the status is OK
                cast(User, link_response.user)
                if link_response.status == &#34;OK&#34;
                else updated_user_after_email_verification
            )
            return RecoverAccountPOSTResponse(
                email=email_for_whom_token_was_generated,
                user=user_after_we_tried_linking,
            )

        token_consumption_response = (
            await options.recipe_implementation.consume_recover_account_token(
                token=token,
                tenant_id=tenant_id,
                user_context=user_context,
            )
        )

        if isinstance(
            token_consumption_response, RecoverAccountTokenInvalidErrorResponse
        ):
            return token_consumption_response

        user_id_for_whom_token_was_generated = token_consumption_response.user_id
        email_for_whom_token_was_generated = token_consumption_response.email

        existing_user = await get_user(
            user_id=token_consumption_response.user_id,
            user_context=user_context,
        )

        if existing_user is None:
            # This should happen only cause of a race condition where the user
            # might be deleted before token creation and consumption.
            # Also note that this being undefined doesn&#39;t mean that the webauthn
            # user does not exist, but it means that there is no recipe or primary user
            # for whom the token was generated.
            return RecoverAccountTokenInvalidErrorResponse()

        if not existing_user.is_primary_user:
            # This means that the existing user is not a primary account, which implies that
            # it must be a non linked webauthn account. In this case, we simply update the credential.
            # Linking to an existing account will be done after the user goes through the email
            # verification flow once they log in (if applicable).
            return await do_register_credential_and_verify_email_and_try_link_if_not_primary(
                recipe_user_id=RecipeUserId(
                    recipe_user_id=user_id_for_whom_token_was_generated
                )
            )

        # User is a primary user
        # If this user contains an webauthn account for whom the token was generated,
        # then we update that user&#39;s credential.
        webauthn_user_is_linked_to_existing_user = False
        for login_method in existing_user.login_methods:
            if (
                login_method.recipe_id == &#34;webauthn&#34;
                and login_method.recipe_user_id.get_as_string()
                == user_id_for_whom_token_was_generated
            ):
                webauthn_user_is_linked_to_existing_user = True
                break

        if webauthn_user_is_linked_to_existing_user:
            return await do_register_credential_and_verify_email_and_try_link_if_not_primary(
                recipe_user_id=RecipeUserId(
                    recipe_user_id=user_id_for_whom_token_was_generated
                )
            )

        # This means that the existingUser does not have an webauthn user associated
        # with it. It could now mean that no webauthn user exists, or it could mean that
        # the the webauthn user exists, but it&#39;s not linked to the current account.
        # If a webauthn user doesn&#39;t exist, we will create one, and link it to the existing account.
        # If webauthn user exists, then it means there is some race condition cause
        # then the token should have been generated for that user instead of the primary user,
        # and it shouldn&#39;t have come into this branch. So we can simply send a recover account
        # invalid error and the user can try again.

        # NOTE: We do not ask the dev if we should do account linking or not here
        # cause we already have asked them this when generating an recover account reset token.
        # In the edge case that the dev changes account linking allowance from true to false
        # when it comes here, only a new recipe user id will be created and not linked
        # cause createPrimaryUserIdOrLinkAccounts will disallow linking. This doesn&#39;t
        # really cause any security issue.
        create_user_response = (
            await options.recipe_implementation.create_new_recipe_user(
                tenant_id=tenant_id,
                webauthn_generated_options_id=webauthn_generated_options_id,
                credential=credential,
                user_context=user_context,
            )
        )

        if isinstance(
            create_user_response,
            (
                InvalidCredentialsErrorResponse,
                OptionsNotFoundErrorResponse,
                InvalidOptionsErrorResponse,
                InvalidAuthenticatorErrorResponse,
            ),
        ):
            return create_user_response

        if isinstance(create_user_response, EmailAlreadyExistsErrorResponse):
            # this means that the user already existed and we can just return an invalid
            # token (see the above comment)
            return RecoverAccountTokenInvalidErrorResponse()

        # we mark the email as verified because recover account also requires
        # access to the email to work.. This has a good side effect that
        # any other login method with the same email in existingAccount will also get marked
        # as verified.
        await mark_email_as_verified(
            recipe_user_id=create_user_response.user.login_methods[0].recipe_user_id,
            email=token_consumption_response.email,
        )
        updated_user = await get_user(
            user_id=create_user_response.user.id, user_context=user_context
        )
        if updated_user is None:
            raise Exception(
                &#34;This should never happen: user deleted during recover account&#34;
            )
        create_user_response.user = updated_user

        # Now we try and link the accounts. The function below will try and also
        # create a primary user of the new account, and if it does that, it&#39;s OK..
        # But in most cases, it will end up linking to existing account since the
        # email is shared.
        # We do not take try linking by session here, since this is supposed to be called without a session
        # Still, the session object is passed around because it is a required input for shouldDoAutomaticAccountLinking
        link_response = await AccountLinkingRecipe.get_instance().try_linking_by_account_info_or_create_primary_user(
            tenant_id=tenant_id,
            input_user=create_user_response.user,
            session=None,
            user_context=user_context,
        )

        # Link response user will always be non-None if status == &#34;OK&#34;
        user_after_linking = (
            cast(User, link_response.user)
            if link_response.status == &#34;OK&#34;
            else create_user_response.user
        )

        if (
            link_response.status == &#34;OK&#34;
            and cast(User, link_response.user).id != existing_user.id
        ):
            # this means that the account we just linked to
            # was not the one we had expected to link it to. This can happen
            # due to some race condition or the other.. Either way, this
            # is not an issue and we can just return OK
            pass

        return RecoverAccountPOSTResponse(
            email=token_consumption_response.email,
            user=user_after_linking,
        )

    async def list_credentials_get(
        self,
        *,
        options: APIOptions,
        user_context: UserContext,
        session: SessionContainer,
    ) -&gt; ListCredentialsGETResponse:
        existing_user = await get_user(
            user_id=session.get_user_id(),
            user_context=user_context,
        )
        if existing_user is None:
            raise_general_exception(&#34;User not found&#34;)

        recipe_user_ids = [
            lm.recipe_user_id
            for lm in existing_user.login_methods
            if lm.recipe_id == &#34;webauthn&#34;
        ]

        credentials: List[ListCredentialsGETResponse.Credential] = []

        for recipe_user_id in recipe_user_ids:
            list_credentials_response = (
                await options.recipe_implementation.list_credentials(
                    recipe_user_id=recipe_user_id.get_as_string(),
                    user_context=user_context,
                )
            )

            credentials.extend(list_credentials_response.credentials)

        return ListCredentialsGETResponse(
            credentials=credentials,
        )

    async def register_credential_post(
        self,
        *,
        webauthn_generated_options_id: str,
        credential: RegistrationPayload,
        tenant_id: str,
        session: SessionContainer,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        OkResponseBaseModel,
        GeneralErrorResponse,
        RegisterCredentialPOSTErrorResponse,
    ]:
        error_code_map = {
            &#34;REGISTER_CREDENTIAL_NOT_ALLOWED&#34;: &#34;Cannot register credential due to security reasons. Please try logging in, use a different login method or contact support. (ERR_CODE_007)&#34;,
            &#34;INVALID_AUTHENTICATOR_ERROR&#34;: &#34;The device used for authentication is not supported. Please use a different device. (ERR_CODE_026)&#34;,
            &#34;INVALID_CREDENTIALS_ERROR&#34;: &#34;The credentials are incorrect. Please make sure you are using the correct credentials. (ERR_CODE_025)&#34;,
        }

        mfa_instance = MultiFactorAuthRecipe.get_instance()
        if mfa_instance is not None:
            await assert_allowed_to_setup_factor_else_throw_invalid_claim_error(
                session=session,
                factor_id=FactorIds.WEBAUTHN,
                user_context=user_context,
            )

        generated_options = await options.recipe_implementation.get_generated_options(
            webauthn_generated_options_id=webauthn_generated_options_id,
            tenant_id=tenant_id,
            user_context=user_context,
        )
        if generated_options.status != &#34;OK&#34;:
            return generated_options

        email = generated_options.email
        # NOTE: Following checks will likely never throw an error as the
        # check for type is done in a parent function but they are kept
        # here to be on the safe side.
        if not isinstance(email, str):  # type: ignore
            raise Exception(
                &#34;Should never come here since we already check that the email &#34;
                &#34;value is a string in validate_email_address&#34;
            )

        register_credential_response = (
            await options.recipe_implementation.register_credential(
                webauthn_generated_options_id=webauthn_generated_options_id,
                credential=credential,
                user_context=user_context,
                recipe_user_id=session.get_recipe_user_id().get_as_string(),
            )
        )

        if register_credential_response.status != &#34;OK&#34;:
            return RegisterCredentialNotAllowedErrorResponse(
                reason=get_error_response_reason_from_map(
                    response_status=register_credential_response.status,
                    error_code_map=error_code_map,
                )
            )

        return OkResponseBaseModel()

    async def remove_credential_post(
        self,
        *,
        webauthn_credential_id: str,
        session: SessionContainer,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[
        OkResponseBaseModel, GeneralErrorResponse, CredentialNotFoundErrorResponse
    ]:
        mfa_instance = MultiFactorAuthRecipe.get_instance()
        if mfa_instance is not None:
            await session.assert_claims(
                claim_validators=[
                    MultiFactorAuthClaim.validators.has_completed_mfa_requirements_for_auth()
                ]
            )

        user = await get_user(session.get_user_id(), user_context=user_context)
        if user is None:
            raise_general_exception(&#34;User not found&#34;)

        required_login_methods = [
            lm
            for lm in user.login_methods
            if lm.recipe_id == &#34;webauthn&#34;
            and lm.webauthn is not None
            and webauthn_credential_id in lm.webauthn.credential_ids
        ]
        if len(required_login_methods) == 0:
            raise_general_exception(&#34;User not found&#34;)

        recipe_user_id = required_login_methods[0].recipe_user_id

        remove_credential_response = (
            await options.recipe_implementation.remove_credential(
                webauthn_credential_id=webauthn_credential_id,
                recipe_user_id=recipe_user_id.get_as_string(),
                user_context=user_context,
            )
        )

        if remove_credential_response.status != &#34;OK&#34;:
            return remove_credential_response

        return OkResponseBaseModel()

    async def email_exists_get(
        self,
        *,
        email: str,
        tenant_id: str,
        options: APIOptions,
        user_context: UserContext,
    ) -&gt; Union[EmailExistsGetResponse, GeneralErrorResponse]:
        users = await AccountLinkingRecipe.get_instance().recipe_implementation.list_users_by_account_info(
            tenant_id=tenant_id,
            account_info=AccountInfoInput(email=email),
            do_union_of_account_info=False,
            user_context=user_context,
        )

        webauthn_user_exists = False
        for user in users:
            for login_method in user.login_methods:
                if (
                    login_method.recipe_id == &#34;webauthn&#34;
                    and login_method.has_same_email_as(email)
                ):
                    webauthn_user_exists = True
                    break

        return EmailExistsGetResponse(exists=webauthn_user_exists)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface">APIInterface</a></li>
<li><a title="supertokens_python.types.recipe.BaseAPIInterface" href="../../../types/recipe.html#supertokens_python.types.recipe.BaseAPIInterface">BaseAPIInterface</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.email_exists_get"><code class="name flex">
<span>async def <span class="ident">email_exists_get</span></span>(<span>self, *, email:str, tenant_id:str, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.recipe.webauthn.interfaces.api.EmailExistsGetResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.EmailExistsGetResponse">EmailExistsGetResponse</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.generate_recover_account_token_post"><code class="name flex">
<span>async def <span class="ident">generate_recover_account_token_post</span></span>(<span>self, *, email:str, tenant_id:str, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.types.response.OkResponseBaseModel" href="../../../types/response.html#supertokens_python.types.response.OkResponseBaseModel">OkResponseBaseModel</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.api.RecoverAccountNotAllowedErrorResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.RecoverAccountNotAllowedErrorResponse">RecoverAccountNotAllowedErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.list_credentials_get"><code class="name flex">
<span>async def <span class="ident">list_credentials_get</span></span>(<span>self, *, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any], session:<a title="supertokens_python.recipe.session.interfaces.SessionContainer" href="../../session/interfaces.html#supertokens_python.recipe.session.interfaces.SessionContainer">SessionContainer</a>) ><a title="supertokens_python.recipe.webauthn.interfaces.recipe.ListCredentialsResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.ListCredentialsResponse">ListCredentialsResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.recover_account_post"><code class="name flex">
<span>async def <span class="ident">recover_account_post</span></span>(<span>self, *, token:str, webauthn_generated_options_id:str, credential:<a title="supertokens_python.recipe.webauthn.interfaces.recipe.RegistrationPayload" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.RegistrationPayload">RegistrationPayload</a>, tenant_id:str, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.recipe.webauthn.interfaces.api.RecoverAccountPOSTResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.RecoverAccountPOSTResponse">RecoverAccountPOSTResponse</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.RecoverAccountTokenInvalidErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.RecoverAccountTokenInvalidErrorResponse">RecoverAccountTokenInvalidErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse">InvalidCredentialsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.OptionsNotFoundErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.OptionsNotFoundErrorResponse">OptionsNotFoundErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse">InvalidOptionsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidAuthenticatorErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidAuthenticatorErrorResponse">InvalidAuthenticatorErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.register_credential_post"><code class="name flex">
<span>async def <span class="ident">register_credential_post</span></span>(<span>self, *, webauthn_generated_options_id:str, credential:<a title="supertokens_python.recipe.webauthn.interfaces.recipe.RegistrationPayload" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.RegistrationPayload">RegistrationPayload</a>, tenant_id:str, session:<a title="supertokens_python.recipe.session.interfaces.SessionContainer" href="../../session/interfaces.html#supertokens_python.recipe.session.interfaces.SessionContainer">SessionContainer</a>, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.types.response.OkResponseBaseModel" href="../../../types/response.html#supertokens_python.types.response.OkResponseBaseModel">OkResponseBaseModel</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse">InvalidCredentialsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.OptionsNotFoundErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.OptionsNotFoundErrorResponse">OptionsNotFoundErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse">InvalidOptionsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.api.RegisterCredentialNotAllowedErrorResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.RegisterCredentialNotAllowedErrorResponse">RegisterCredentialNotAllowedErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidAuthenticatorErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidAuthenticatorErrorResponse">InvalidAuthenticatorErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.register_options_post"><code class="name flex">
<span>async def <span class="ident">register_options_post</span></span>(<span>self, *, tenant_id:str, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any], **kwargs:Unpack[<a title="supertokens_python.recipe.webauthn.interfaces.api.RegisterOptionsPOSTKwargsInput" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.RegisterOptionsPOSTKwargsInput">RegisterOptionsPOSTKwargsInput</a>]) >Union[<a title="supertokens_python.recipe.webauthn.interfaces.api.RegisterOptionsPOSTResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.RegisterOptionsPOSTResponse">RegisterOptionsPOSTResponse</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.RecoverAccountTokenInvalidErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.RecoverAccountTokenInvalidErrorResponse">RecoverAccountTokenInvalidErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse">InvalidOptionsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidEmailErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidEmailErrorResponse">InvalidEmailErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.remove_credential_post"><code class="name flex">
<span>async def <span class="ident">remove_credential_post</span></span>(<span>self, *, webauthn_credential_id:str, session:<a title="supertokens_python.recipe.session.interfaces.SessionContainer" href="../../session/interfaces.html#supertokens_python.recipe.session.interfaces.SessionContainer">SessionContainer</a>, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.types.response.OkResponseBaseModel" href="../../../types/response.html#supertokens_python.types.response.OkResponseBaseModel">OkResponseBaseModel</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.CredentialNotFoundErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.CredentialNotFoundErrorResponse">CredentialNotFoundErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_in_options_post"><code class="name flex">
<span>async def <span class="ident">sign_in_options_post</span></span>(<span>self, *, tenant_id:str, options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.recipe.webauthn.interfaces.api.SignInOptionsPOSTResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.SignInOptionsPOSTResponse">SignInOptionsPOSTResponse</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse">InvalidOptionsErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_in_post"><code class="name flex">
<span>async def <span class="ident">sign_in_post</span></span>(<span>self, *, webauthn_generated_options_id:str, credential:<a title="supertokens_python.recipe.webauthn.interfaces.recipe.AuthenticationPayload" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.AuthenticationPayload">AuthenticationPayload</a>, tenant_id:str, session:Optional[<a title="supertokens_python.recipe.session.interfaces.SessionContainer" href="../../session/interfaces.html#supertokens_python.recipe.session.interfaces.SessionContainer">SessionContainer</a>], should_try_linking_with_session_user:Optional[bool], options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.recipe.webauthn.interfaces.api.SignInPOSTResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.SignInPOSTResponse">SignInPOSTResponse</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse">InvalidCredentialsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.api.SignInNotAllowedErrorResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.SignInNotAllowedErrorResponse">SignInNotAllowedErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_up_post"><code class="name flex">
<span>async def <span class="ident">sign_up_post</span></span>(<span>self, *, webauthn_generated_options_id:str, credential:<a title="supertokens_python.recipe.webauthn.interfaces.recipe.RegistrationPayload" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.RegistrationPayload">RegistrationPayload</a>, tenant_id:str, session:Optional[<a title="supertokens_python.recipe.session.interfaces.SessionContainer" href="../../session/interfaces.html#supertokens_python.recipe.session.interfaces.SessionContainer">SessionContainer</a>], should_try_linking_with_session_user:Optional[bool], options:<a title="supertokens_python.recipe.webauthn.interfaces.api.APIOptions" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIOptions">APIOptions</a>, user_context:Dict[str,Any]) >Union[<a title="supertokens_python.recipe.webauthn.interfaces.api.SignUpPOSTResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.SignUpPOSTResponse">SignUpPOSTResponse</a>,<a title="supertokens_python.types.response.GeneralErrorResponse" href="../../../types/response.html#supertokens_python.types.response.GeneralErrorResponse">GeneralErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.api.SignUpNotAllowedErrorResponse" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.SignUpNotAllowedErrorResponse">SignUpNotAllowedErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidAuthenticatorErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidAuthenticatorErrorResponse">InvalidAuthenticatorErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.EmailAlreadyExistsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.EmailAlreadyExistsErrorResponse">EmailAlreadyExistsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidCredentialsErrorResponse">InvalidCredentialsErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.OptionsNotFoundErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.OptionsNotFoundErrorResponse">OptionsNotFoundErrorResponse</a>,<a title="supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse" href="../interfaces/recipe.html#supertokens_python.recipe.webauthn.interfaces.recipe.InvalidOptionsErrorResponse">InvalidOptionsErrorResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface">APIInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_email_exists_get" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_email_exists_get">disable_email_exists_get</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_generate_recover_account_token_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_generate_recover_account_token_post">disable_generate_recover_account_token_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_list_credentials_get" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_list_credentials_get">disable_list_credentials_get</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_recover_account_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_recover_account_post">disable_recover_account_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_register_credential_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_register_credential_post">disable_register_credential_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_register_options_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_register_options_post">disable_register_options_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_remove_credential_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_remove_credential_post">disable_remove_credential_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_sign_in_options_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_sign_in_options_post">disable_sign_in_options_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_sign_in_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_sign_in_post">disable_sign_in_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_sign_up_post" href="../interfaces/api.html#supertokens_python.recipe.webauthn.interfaces.api.APIInterface.disable_sign_up_post">disable_sign_up_post</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h2>Index</h2>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="supertokens_python.recipe.webauthn.api" href="index.html">supertokens_python.recipe.webauthn.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation">APIImplementation</a></code></h4>
<ul class="">
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.email_exists_get" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.email_exists_get">email_exists_get</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.generate_recover_account_token_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.generate_recover_account_token_post">generate_recover_account_token_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.list_credentials_get" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.list_credentials_get">list_credentials_get</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.recover_account_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.recover_account_post">recover_account_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.register_credential_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.register_credential_post">register_credential_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.register_options_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.register_options_post">register_options_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.remove_credential_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.remove_credential_post">remove_credential_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_in_options_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_in_options_post">sign_in_options_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_in_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_in_post">sign_in_post</a></code></li>
<li><code><a title="supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_up_post" href="#supertokens_python.recipe.webauthn.api.implementation.APIImplementation.sign_up_post">sign_up_post</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>
